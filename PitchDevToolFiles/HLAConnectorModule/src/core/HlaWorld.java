package core;

/*
 * DO NOT EDIT!
 * 
 * Automatically generated source code by Pitch Developer Studio
 * Licensed to Guidarly Joseph, SEE, Project Edition
 *
 * Copyright (C) 2006-2023 Pitch Technologies AB. All rights reserved.
 * Use is subject to license terms.
 */

import core.exceptions.*;
import core.impl.HlaWorldImpl;


/**
 * Interface used get to all functions within a HLA Federation. 
 * <p>
 * Generated by Pitch Developer Studio version 6.2.0
 * <br>
 * Licensed to Guidarly Joseph, SEE, Project Edition
 * <p>
 * This class is <code>ThreadSafe</code> as defined by <i>Java Concurrency in Practice</i>,
 * see <a href="http://jcip.net/annotations/doc/net/jcip/annotations/package-summary.html">jcip.net</a>.
 */
public interface HlaWorld {

   /**
    * Factory used to create an instance of the HlaWorld.
    * <p>
    * This class is <code>ThreadSafe</code> as defined by <i>Java Concurrency in Practice</i>,
 * see <a href="http://jcip.net/annotations/doc/net/jcip/annotations/package-summary.html">jcip.net</a>.
    */
   public static class Factory {
      /**
       * Creates a HlaWorld in auto evoke mode with the default settings and timestamps.
       *
       * @return the HlaWorld instance
       *
       * @see #create(HlaSettings, boolean, HlaTimeStampFactory)
       */
      public static HlaWorld create() {
         return create(false);
      }

      /**
       * Creates a HlaWorld in auto evoke mode with the specified settings and default timestamps.
       *
       * @param settings         settings for this <code>HlaWorld</code>.
       *
       * @return the HlaWorld instance
       *
       * @see #create(HlaSettings, boolean, HlaTimeStampFactory)
       */
      public static HlaWorld create(HlaSettings settings) {
         return create(settings, false);
      }

      /**
       * Creates a HlaWorld with the default settings and timestamps.
       *
       * @param manualEvokeMode  if True, the created instance will be in manual evoke mode, otherwise auto.
       *
       * @return the HlaWorld instance
       *
       * @see #create(HlaSettings, boolean, HlaTimeStampFactory)
       */
      public static HlaWorld create(boolean manualEvokeMode) {
         return create(null, manualEvokeMode, null);
      }

      /**
       * Creates a HlaWorld with the specified settings and default timestamps.
       *
       * @param settings         settings for this <code>HlaWorld</code>.
       * @param manualEvokeMode  if True, the created instance will be in manual evoke mode, otherwise auto.
       *
       * @return the HlaWorld instance
       *
       * @see #create(HlaSettings, boolean, HlaTimeStampFactory)
       */
      public static HlaWorld create(HlaSettings settings, boolean manualEvokeMode) {
         return create(settings, manualEvokeMode, null);
      }

      /**
       * Creates a HlaWorld with the specified settings and timestamps.
       *
       * The parameter <code>manualEvokeMode</code> decides if the instance will run in manual or auto evoke mode.
       *
       * <h3>Auto evoke mode</h3>
       * All notifications for this HlaWorld instance will be delivered in the same thread, a thread that is created
       * by HlaWorld. The notifications will be delivered automatically , as fast as possible. No need to call any
       * <code>evoke</code> methods.
       *
       * <h3>Manual evoke mode</h3>
       * In this mode notifications will be delivered when one of the evoke methods are called. The notification is
       * delivered in the same thread that makes the call to the notification method.
       * Note that the HlaWorld will be updated asynchronously, without need for <code>evoke</code>.
       *
       * If HlaSettings has been overridden with a settings file, the supplied settings will <b>not</b> be used.
       * A new settings object will be created using the settings specified in the file.
       *
       * Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
       *
       * @param settings         settings for this <code>HlaWorld</code>.
       * @param manualEvokeMode  if True, the created instance will be in manual evoke mode, otherwise auto.
       * @param timeStampFactory factory used to create timestamps. The default factory is used if <code>null</code> is supplied.
       *                         The timestamp factory can also be used to set the <code>HLA User Defined Tag</code>.
       *
       * @return the HlaWorld instance
       */
      public static HlaWorld create(HlaSettings settings, boolean manualEvokeMode, HlaTimeStampFactory timeStampFactory) {
         return new HlaWorldImpl(settings, manualEvokeMode, timeStampFactory);
      }

      private Factory() {
      }
   }


   /**
    * An ExceptionListener is notified of internal exceptions.
    */
   public interface ExceptionListener {
      /**
       * This method is called when an exception has been caught.
       *
       * @param exception  The exception that was caught.
       * @param timeStamp  The time when the exception was initiated.
       * @param logicalTime  The logical time when the exception was initiated.
       */
      void exceptionThrown(Throwable exception, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime);
   }

   /**
    * Connect to a federation. This will connect to the RTI, join and preform publish and subscribe HLA calls.
    * The name of the federation, the CRC location and other settings are defined in the settings supplied to
    * {@link Factory#create}
    *
    * @return the logical time for the current frame.
    *
    * @throws HlaConnectException            if failed to connect to the RTI
    * @throws HlaInvalidLicenseException     if the license is not valid
    * @throws HlaFomException                if the FOM is not correct
    * @throws HlaRtiException                if there are RTI related problems
    * @throws HlaInternalException           if there are internal problems
    * @throws HlaNotConnectedException       if the federate was disconnected during initialization
    * @throws HlaInvalidLogicalTimeException if step size or lookahead from HlaSettings is invalid
    * @throws HlaSaveInProgressException     if a federation save is in progress
    * @throws HlaRestoreInProgressException  if a federation restore is in progress
    * @throws HlaNormalizerException         if all Normalizers are not set
    */
   HlaLogicalTime connect() throws HlaConnectException, HlaInvalidLicenseException, HlaFomException, HlaRtiException,
                                   HlaInternalException, HlaNotConnectedException, HlaInvalidLogicalTimeException,
                                   HlaSaveInProgressException, HlaRestoreInProgressException, HlaNormalizerException;

   /**
    * Disconnect from the federation.
    *
    * @throws HlaFederateOwnsAttributeException   if ownership acquisitions are pending or if attributes are owned
    *                                               and this not handled by the resign action
    * @throws HlaRtiException                     if there are RTI related problems
    * @throws HlaInternalException                if there are internal problems
    */
   void disconnect() throws HlaFederateOwnsAttributeException, HlaRtiException, HlaInternalException;

   /**
    * Enable time management. The federate will become regulating and/or constrained based on the settings objects supplied
    * on create. For this method to have any effect, the tuning flag ENABLE_TIME_MANAGEMENT_ON_CONNECT must be false.
    *
    * Note that this method will do nothing if constrained and regulating are false in settings.
    * Note that this method will do nothing if time management is already enabled, i.e. calling this multiple times has no effect.
    *
    * @return true if time management was enabled, otherwise false
    *
    * @throws HlaRtiException                     if there are RTI related problems
    * @throws HlaInvalidLogicalTimeException      if step size or lookahead from HlaSettings is invalid
    * @throws HlaInternalException                if there are internal problems
    * @throws HlaNotConnectedException            if the federate was disconnected during initialization
    */
   boolean enableTimeManagement() throws HlaRtiException, HlaInvalidLogicalTimeException, HlaInternalException, HlaNotConnectedException;

   /**
    * Advance the logical time to the next frame. This will perform the Time Advance Request HLA call.
    *
    * Note that this method does not support 0-lookahead, use {@link #advanceToNextEvent()} instead.
    *
    * Note that this method is an implicit {@link #evokeAll()} in manual evoke mode, to verify that all
    * notifications for the previous time has been processed before advancing to the next frame.
    *
    * @return the logical time for the new, now current, frame.
    *
    * @throws HlaInvalidLogicalTimeException    if the logical time is not valid
    * @throws HlaInTimeAdvancingStateException  if the federate is in the time advancing state already
    * @throws HlaRtiException                   if there are RTI related problems
    * @throws HlaInternalException              if there are internal problems
    * @throws HlaNotConnectedException          if the federate was disconnected during initialization
    * @throws HlaSaveInProgressException        if a federation save is in progress
    * @throws HlaRestoreInProgressException     if a federation restore is in progress
    */
   HlaLogicalTime advanceToNextFrame() throws HlaRtiException, HlaInternalException,
                                                    HlaNotConnectedException,
                                                    HlaInvalidLogicalTimeException,
                                                    HlaInTimeAdvancingStateException,
                                                    HlaSaveInProgressException,
                                                    HlaRestoreInProgressException;

   /**
    * Advance the logical time to the next event or, if no events are available, to the next frame.
    * This will perform the Next Message Request Available HLA call. This method support 0-lookahead so
    * that messages may be sent with the same logical time as the federate has advanced to.
    *
    * Note that this method is an implicit {@link #evokeAll()} in manual evoke mode, to verify that all
    * notifications for the previous time has been processed before advancing to the next event.
    *
    * @return the logical time for the new, now current, frame.
    *
    * @throws HlaInvalidLogicalTimeException    if the logical time is not valid
    * @throws HlaInTimeAdvancingStateException  if the federate is in the time advancing state already
    * @throws HlaRtiException                   if there are RTI related problems
    * @throws HlaInternalException              if there are internal problems
    * @throws HlaNotConnectedException          if the federate was disconnected during initialization
    * @throws HlaSaveInProgressException        if a federation save is in progress
    * @throws HlaRestoreInProgressException     if a federation restore is in progress
    */
   HlaLogicalTime advanceToNextEvent() throws HlaRtiException, HlaInternalException,
                                                    HlaNotConnectedException,
                                                    HlaInvalidLogicalTimeException,
                                                    HlaInTimeAdvancingStateException,
                                                    HlaSaveInProgressException,
                                                    HlaRestoreInProgressException;

   /**
    * Advance to the specified logical time.
    * This will preform the Time Advance Request HLA call.
    *
    * Note that this method is an implicit {@link #evokeAll()} in manual evoke mode, to verify that all
    * notifications for the previous time has been processed before advancing to the new time.
    *
    * @param logicalTime desired new logical time
    *
    * @return the logical time for the new, now current, frame.
    *
    * @throws HlaInvalidLogicalTimeException    if the logical time is not valid
    * @throws HlaInTimeAdvancingStateException  if the federate is in the time advancing state already
    * @throws HlaRtiException                   if there are RTI related problems
    * @throws HlaInternalException              if there are internal problems
    * @throws HlaNotConnectedException          if the federate was disconnected during initialization
    * @throws HlaSaveInProgressException        if a federation save is in progress
    * @throws HlaRestoreInProgressException     if a federation restore is in progress
    */
    HlaLogicalTime advanceToLogicalTime(HlaLogicalTime logicalTime) throws HlaRtiException, HlaInternalException,
                                                                                       HlaNotConnectedException,
                                                                                       HlaInvalidLogicalTimeException,
                                                                                       HlaInTimeAdvancingStateException,
                                                                                       HlaSaveInProgressException,
                                                                                       HlaRestoreInProgressException;

   /**
    * Invoke this <code>runnable</code> when in the granted state.
    * <p>
    * The <code>runnable</code> is invoked directly on this thread if the federate is in the granted state,
    * otherwise the <code>runnable</code> will be invoked when the federate is granted. Note that the federate
    * can not enter the advancing state until the <code>runnable</code> has completed.
    *
    * @param runnable to be invoked when granted
    */
   void invokeWhenGranted(Runnable runnable);

   /**
    * Get the current time.
    *
    * @return the current time.
    */
   HlaTimeStamp getCurrentTime();

   /**
    * Get timestamp factory.
    *
    * @return the timestamp factory.
    */
   HlaTimeStampFactory getTimeStampFactory();

   /**
    * Get the logical time for the current frame.
    * This is the same as current logical time in the RTI.
    * Updated when a new time is granted by the RTI.
    *
    * @return the logical time for the current frame.
    */
   HlaLogicalTime getCurrentLogicalTime();

   /**
    * Get the logical time for the next frame.
    * Updated when a new time is granted by the RTI
    * to <code>granted time + step size</code>.
    *
    * @return the logical time for the next frame.
    */
   HlaLogicalTime getNextLogicalTime();

   /**
    * Get the next logical time that is valid to use for sending events.
    * This is usually same as <code>next logical time</code>.
    * Updated to <code>next logical time + look-ahead</code> when advancing,
    * and updated to <code>granted time + look-ahead</code> when granted.
    *
    * @return the next valid logical time that is valid to use for sending events.
    */
   HlaLogicalTime getDefaultSendTime();

   /**
    * Create a new logical time with the supplied value.
    *
    * @param value value to use
    *
    * @return the new logical time with the supplied value.
    */
   HlaLogicalTime createLogicalTime(long value);

   /**
    * Create an invalid logical time.
    *
    * @return the invalid logical time.
    */
   HlaLogicalTime createInvalidLogicalTime();

   /**
    * Get settings.
    *
    * @return settings.
    */
   HlaSettings getSettings();

   /**
    * Get the encoded <code>HLA federate handle</code> for this federate.
    *
    * @return the encoded <code>HLA federate handle</code> for this federate, or <code>null</code> if not joined.
    */
   byte[] getEncodedHlaFederateHandle();

   /**
    * Get the FederateId for this federate.
    *
    * @return the FederateId for this federate
    */
    HlaFederateId getFederateId();

   /**
    * Gives the number of pending notifications.
    *
    * @return the number of pending notifications.
    */
   int peek();

   /**
    * Evokes a single notification from the notification queue. The notification will be called from this thread.
    * This method will return after the notification has returned. If there are no pending notifications,
    * this method will return immediately.
    *
    * If this HlaWorld is in auto evoke mode, this method will be a no op.
    *
    * Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    */
   void evoke();

   /**
    * Evokes all pending notifications from the notification queue. The notifications will be called from this
    * thread, one at a time. This method returns when the notification queue is empty.
    *
    * Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    *
    * If this HlaWorld is in auto evoke mode, this method will be a no op.
    */
   void evokeAll();

   /**
    * Evokes notifications for at least <code>millis</code> milliseconds with this thread.
    * If all pending notifications are processed before <code>millis</code> milliseconds have elapsed,
    * the current thread is suspended until either some more notifications arrive, or the time has elapsed.
    *
    * Note that this method could return even when there are pending notifications left.
    *
    * If this HlaWorld is in auto evoke mode, this will suspend the current thread until the time has elapsed.
    *
    * Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    *
    * @param millis The minimum time, in ms, to process notifications.
    */
   void evokeAll(long millis);

   /**
    * Disable automatic invocations of notifications. No <b>new</b> notifications will be invoked after
    * <code>disableNotifications()</code> has <b>returned</b>.
    *
    * Note that notifications has to be manually enabled once disabled. This can be done with the following code:
    * <pre><code>
    * _hlaWorld.disableNotifications();
    * try {
    *    //perform task that generates notifications that can not be handled until after this block
    * } finally {
    *   _hlaWorld.enableNotifications();
    * }
    *
    * </code></pre>
    *
    * If this HlaWorld is in manual evoke mode, this method will be a no op.
    */
   void disableNotifications();

   /**
    * Enable automatic invocations of notifications.
    *
    * Note that the HlaWorld is started in the enabled state, so notifications has to be disabled first before
    * this function has any effect.
    *
    * If this HlaWorld is in manual evoke mode, this method will be a no op.
    */
   void enableNotifications();

   /**
    * Get the HLAobjectRoot manager.
    *
    * @return the HLAobjectRoot manager
    */
   HlaHLAobjectRootManager getHlaHLAobjectRootManager();

   /**
    * Get the PhysicalEntity manager.
    *
    * @return the PhysicalEntity manager
    */
   HlaPhysicalEntityManager getHlaPhysicalEntityManager();

   /**
    * Get the DynamicalEntity manager.
    *
    * @return the DynamicalEntity manager
    */
   HlaDynamicalEntityManager getHlaDynamicalEntityManager();

   /**
    * Get the Payload manager.
    *
    * @return the Payload manager
    */
   HlaPayloadManager getHlaPayloadManager();

   /**
    * Get the Launcher manager.
    *
    * @return the Launcher manager
    */
   HlaLauncherManager getHlaLauncherManager();

   /**
    * Get the PhysicalInterface manager.
    *
    * @return the PhysicalInterface manager
    */
   HlaPhysicalInterfaceManager getHlaPhysicalInterfaceManager();

   /**
    * Get the ReferenceFrame manager.
    *
    * @return the ReferenceFrame manager
    */
   HlaReferenceFrameManager getHlaReferenceFrameManager();

   /**
    * Get the Moon manager.
    *
    * @return the Moon manager
    */
   HlaMoonManager getHlaMoonManager();

   /**
    * Get the ExecutionConfiguration manager.
    *
    * @return the ExecutionConfiguration manager
    */
   HlaExecutionConfigurationManager getHlaExecutionConfigurationManager();

   /**
    * Get the interaction manager.
    *
    * @return the interaction manager
    */
   HlaInteractionManager getHlaInteractionManager();

   /**
    * Get the save and restore manager.
    *
    * @return the save and restore manager
    */
   HlaSaveRestoreManager getHlaSaveRestoreManager();

   /**
    * Sets the exception handler for this HlaWorld to <code>exceptionListener</code>.
    * The exception handler is notified when this HlaWorld catches exceptions.
    *
    * @param exceptionListener   The exception handler for this HlaWorld,
    *                            if <code>null</code> the default exception listener will be used.
    */
   void setExceptionListener(ExceptionListener exceptionListener);

   /**
    * Add a HlaWorldListener.
    *
    * @param listener HlaWorldListener to add
    */
   void addHlaWorldListener(HlaWorldListener listener);

   /**
    * Remove a HlaWorldListener.
    *
    * @param listener HlaWorldListener to remove
    */
   void removeHlaWorldListener(HlaWorldListener listener);
}
