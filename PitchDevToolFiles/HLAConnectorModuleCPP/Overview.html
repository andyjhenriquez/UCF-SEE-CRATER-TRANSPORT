<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--
   DO NOT EDIT!

   Automatically generated by Pitch Developer Studio
   Licensed to Roberto Cedeno, SEE, Project Edition

   Copyright (C) 2006-2023 Pitch Technologies AB. All rights reserved.
   Use is subject to license terms.
-->
<html>

<head>
    <title>Overview Documentation</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >

<script type="application/javascript">

    function createTOCEntry(node) {
        var li = document.createElement("li");
        var a = document.createElement("a");
        a.setAttribute("href","#" + node.id);
        a.innerHTML = node.innerHTML;
        li.appendChild(a);
        return li;
    }

    function prependSectionNumber(node,sectionNumber) {
        node.insertBefore(document.createTextNode(sectionNumber + ". "), node.firstChild);
        node.id = "section" + sectionNumber;
    }

    function generateTOC(toc) {
        var h2level = 0;
        var h3level = 0;
        toc = toc.appendChild(document.createElement("ul"));
        for (var i = 0; i < document.body.childNodes.length; i++) {
            var node = document.body.childNodes[i];
            var tagName = node.nodeName.toLowerCase();
            var sectionNumber = "";
            if (tagName == "h2") {
                ++h2level;
                h3level = 0;
                prependSectionNumber(node,h2level);
                toc.appendChild(createTOCEntry(node));
            } else if (tagName == "h3") {
                ++h3level;

                //Create new level
                if (h3level == 1) {
                    toc.lastChild.appendChild(document.createElement("ul"));
                }
                prependSectionNumber(node,h2level + "." + h3level);
                toc.lastChild.lastChild.appendChild(createTOCEntry(node));
            }
        }
    }

</script>

<style type="text/css">

h3, h4 {
    color: #555;
}

table {
    margin-left: 30px;
    border-collapse: collapse;
    border-spacing: 0;
    border: 1px #fff solid;
}

thead {
    background-color: #666;
    color: #fff;
}

th {
    font-weight: bold;
    padding-left: 10px;
    padding-right: 10px;
}

tbody {
    background-color: #ddd;
    color: #000;
    border: 1px #fff solid;
}

td {
    font-style: normal;
    padding-left: 10px;
    padding-right: 10px;
    border: 1px #fff solid;
}

blockquote {
    margin-left: 30px;
    border: 1px dashed;
    padding-left: 10px;
    background-color: #ddd;
    overflow: auto;
}

div#toc ul {
    list-style-type: none;
}

a {
    text-decoration: none;
}

/* Fix for to much padding of <pre> inside <table> */
table pre {
    margin: 0;
}

</style>
</head>

<body onload="generateTOC(document.getElementById('toc'));">


<h1>Overview Documentation</h1>

<h2>General</h2>
<p>You have successfully generated code for your application. This document provides an overview of generated code.
A full set of documentation of all generated code is also available in the generated Doxygen
(<a href="doxygen/html/index.html">link</a>).

<h3>Table of Contents</h3>
<div id="toc"></div>

<h2>Getting Connected to an HLA Federation</h2>

To connect to an HLA federation you need an instance of the object <code>HlaWorld</code>. An <code>HlaWorld</code>
instance can be created by the <code>HlaWorld::Factory</code> class. When creating an <code>HlaWorld</code> you can
either use the default settings that was defined when the code was generated or supply your own implementation of the
<code>HlaSettings</code> interface.
<p>

When you have created a <code>HlaWorld</code> you can call the <code>connect</code> method which connects to the
federation. When you wish to leave the federation you should simply call the <code>disconnect</code> method.
<p>

This is what the C++ code may look like:

<blockquote><pre>
HlaWorldPtr hlaWorld = HlaWorld::Factory::create();
hlaWorld->connect();
// simulate...
hlaWorld->disconnect();
</pre></blockquote>

If you are going to connect to several HLA federations you need to create one <code>HlaWorld</code>
instance for each federation. Note that you should not modify the generated code for <code>HlaWorld</code>
and <code>HlaSettings</code>.

It's possible to add a world listener to <code>HlaWorld</code> that will be notified when <code>HlaWorld</code>
is connected or disconnected. For example:

<blockquote><pre>
class WorldListener : public HlaWorldListener::Adapter {
public:
    void connected(HlaTimeStampPtr timeStamp) {cout << "Connected";}

    void disconnected(HlaTimeStampPtr timeStamp) {cout << "Disconnected";}
};
HlaWorldListenerPtr worldListener(new WorldListener());
hlaWorld->addHlaWorldListener(worldListener);
</pre></blockquote>


<h3>Object Classes</h3>

For each object class in the federation that you will support, a number of classes have been
generated. You have chosen to support the following classes:

<ol>
    <li>HlaHLAobjectRoot</li>
    <li>HlaPhysicalEntity</li>
    <li>HlaDynamicalEntity</li>
    <li>HlaPayload</li>
    <li>HlaLauncher</li>
    <li>HlaPhysicalInterface</li>
    <li>HlaReferenceFrame</li>
    <li>HlaMoon</li>
    <li>HlaExecutionConfiguration</li>
</ol>


<h2>Handling Interactions</h2>

If you have chosen to direct some interaction to a particular object class, please read more
about these in the corresponding object class descriptions (below).

<h3>Receiving Global Interactions</h3>

To receive global interactions you need to implement the <code>HlaInteractionListener</code> interface, or
create a subclass of the <code>HlaInteractionListener::Adapter</code>, and attach it as a listener to
<code>HlaInteractionManager</code> using the <code>addHlaInteractionListener</code> method. You should then implement
the handling methods that you need from the <code>HlaInteractionListener</code> in your implementation. If
you for example have a globally handled interaction called <code>loadScenario</code>
you need to provide the following code.

<blockquote><pre>
class MyInteractionListener : public HlaInteractionListener::Adapter {
public:
    void loadScenario(bool local,
                      HlaLoadScenarioParametersPtr parameters,
                      HlaTimeStampPtr timeStamp,
                      HlaLogicalTimePtr logicalTime) {
        // Add implementation to handle interaction
    }
};
HlaInteractionListenerPtr myInteractionListener(new MyInteractionListener());
hlaWorld->getHlaInteractionManager()->addHlaInteractionListener(myInteractionListener);
</pre></blockquote>

The following global interactions are supported as calls to your interaction listener:

<blockquote><pre>
hLAinteractionRoot(bool local, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
startStop(bool local, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
modeTransitionRequest(bool local, HlaModeTransitionRequestParametersPtr parameters, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

<h3>Sending Global Interactions</h3>

To send a global interaction you need to use the <code>HlaInteractionManager</code> to obtain an interaction
object, set the desired parameter values and finally call the <code>sendInteraction</code> method. If you for example have a
globally handled interaction called <code>loadScenario</code>, with two parameters called name and data, you can send that interaction as follows:

<blockquote><pre>
HlaLoadScenarioInteractionPtr loadScenario = hlaWorld->getHlaInteractionManager()->getHlaLoadScenarioInteraction();
loadScenario->setName("Alpha");
loadScenario->setData(135);
loadScenario->sendInteraction();
</pre></blockquote>

The following global interactions are available in your interaction manager:

<blockquote><pre>
HlaHLAinteractionRootInteractionPtr hLAinteractionRoot = hlaWorld->getHlaInteractionManager()->getHlaHLAinteractionRootInteraction();
HlaStartStopInteractionPtr startStop = hlaWorld->getHlaInteractionManager()->getHlaStartStopInteraction();
HlaModeTransitionRequestInteractionPtr modeTransitionRequest = hlaWorld->getHlaInteractionManager()->getHlaModeTransitionRequestInteraction();
</pre></blockquote>

Note that you should not modify the generated code.


<h2>Working with Object Classes</h2>

For each object class in the FOM that you have chosen to support, several C++ classes have
been generated.
<p>

Each object class has a <code>Manager</code> that keeps track of all local and remote instances. A listener
can be attached to the manager to get notification when instances are discovered, initialized and
deleted. The manager is also used to create new local instances.
<p>

Each object class has several supporting interfaces:
<ul>
    <li>An interface with all the <code>Attribute</code>s defined. Getters exists to be able to get an instances attribute values.
    </li>
    <li>An <code>Updater</code> that is used when changing attribute values for a local instance</li>
    <li>Two <code>Listener</code>s for when the attribute values of an instance is updated, one contains the
        set of updated attributes without values and the other contains each updated attribute
        with the new value.
    </li>
</ul>

How to attach a listener to an object instance, Aircraft example:
<blockquote><pre>
class MyAircraftValueListener : public HlaAircraftValueListener::Adapter {
public:
    void positionUpdated (HlaAircraftPtr aircraft, PositionRec position, bool validOldPosition, PositionRec oldPosition, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime) {
        //Do something when Aircraft position is updated.
    }
};

class MyHlaAircraftManagerListener : public HlaAircraftManagerListener::Adapter {
    void hlaAircraftDiscovered(HlaAircraftPtr aircraft, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime) {
        HlaAircraftValueListenerPtr myAircraftValueListener(new MyAircraftValueListener());
        aircraft->addHlaAircraftValueListener(myAircraftValueListener);
    }
};
</pre></blockquote>

All the classes and interfaces are described in more detail below.



<h3>HLAobjectRoot Class</h3>


<h4>Working with HLAobjectRoot Instances</h4>

To work with HLAobjectRoot you first need to get the <code>HlaHLAobjectRootManager</code> instance which is
available through the <code>HlaWorld->getHlaHLAobjectRootManager</code> method.
<p>

To work with object instances you may use the <code>HlaHLAobjectRootManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaHLAobjectRootManagerPtr hLAobjectRootmanager = world->getHlaHLAobjectRootManager();
hLAobjectRootmanager->getHlaHLAobjectRoots();
hLAobjectRootmanager->getLocalHlaHLAobjectRoots();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
hLAobjectRootManager->getHLAobjectRootByHlaInstanceName(const std::wstring& hlaInstanceName)
hLAobjectRootManager->getHLAobjectRootByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each HLAobjectRoot attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaHLAobjectRoot->getHlaHLAobjectRootAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaHLAobjectRootValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
</pre></blockquote>

You may also implement the <code>HlaHLAobjectRootValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaHLAobjectRootListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaHLAobjectRootListener::attributesUpdated(HlaHLAobjectRootPtr hLAobjectRoot, HlaEnumSet&lt;HlaHLAobjectRootAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of HLAobjectRoot:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaHLAobjectRootManager()->createLocalHlaHLAobjectRoot(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaHLAobjectRootManager()->createLocalHlaHLAobjectRoot(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaHLAobjectRootUpdater</code> as follows:

<blockquote><pre>
HlaHLAobjectRootUpdaterPtr updater = myInstance->getHlaHLAobjectRootUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>PhysicalEntity Class</h3>


<h4>Working with PhysicalEntity Instances</h4>

To work with PhysicalEntity you first need to get the <code>HlaPhysicalEntityManager</code> instance which is
available through the <code>HlaWorld->getHlaPhysicalEntityManager</code> method.
<p>

To work with object instances you may use the <code>HlaPhysicalEntityManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaPhysicalEntityManagerPtr physicalEntitymanager = world->getHlaPhysicalEntityManager();
physicalEntitymanager->getHlaPhysicalEntitys();
physicalEntitymanager->getLocalHlaPhysicalEntitys();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
physicalEntityManager->getPhysicalEntityByHlaInstanceName(const std::wstring& hlaInstanceName)
physicalEntityManager->getPhysicalEntityByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each PhysicalEntity attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
bool hasName();
std::wstring getName();
HlaTimeStamped&lt; std::wstring > getNameTimeStamped();

bool hasType();
std::wstring getType();
HlaTimeStamped&lt; std::wstring > getTypeTimeStamped();

bool hasStatus();
std::wstring getStatus();
HlaTimeStamped&lt; std::wstring > getStatusTimeStamped();

bool hasParentReferenceFrame();
std::wstring getParentReferenceFrame();
HlaTimeStamped&lt; std::wstring > getParentReferenceFrameTimeStamped();

bool hasState();
SpaceTimeCoordinateState getState();
HlaTimeStamped&lt; SpaceTimeCoordinateState > getStateTimeStamped();

bool hasAcceleration();
std::vector</* 3 */ double > getAcceleration();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getAccelerationTimeStamped();

bool hasRotationalAcceleration();
std::vector</* 3 */ double > getRotationalAcceleration();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getRotationalAccelerationTimeStamped();

bool hasCenterOfMass();
std::vector</* 3 */ double > getCenterOfMass();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getCenterOfMassTimeStamped();

bool hasBodyWrtStructural();
AttitudeQuaternion getBodyWrtStructural();
HlaTimeStamped&lt; AttitudeQuaternion > getBodyWrtStructuralTimeStamped();

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaPhysicalEntity->getHlaPhysicalEntityAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaPhysicalEntityValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaPhysicalEntityValueListener::Adapter::nameUpdated(HlaPhysicalEntityPtr physicalEntity, std::wstring name, bool validOldName, std::wstring oldName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalEntityValueListener::Adapter::typeUpdated(HlaPhysicalEntityPtr physicalEntity, std::wstring type, bool validOldType, std::wstring oldType, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalEntityValueListener::Adapter::statusUpdated(HlaPhysicalEntityPtr physicalEntity, std::wstring status, bool validOldStatus, std::wstring oldStatus, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalEntityValueListener::Adapter::parentReferenceFrameUpdated(HlaPhysicalEntityPtr physicalEntity, std::wstring parentReferenceFrame, bool validOldParentReferenceFrame, std::wstring oldParentReferenceFrame, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalEntityValueListener::Adapter::stateUpdated(HlaPhysicalEntityPtr physicalEntity, SpaceTimeCoordinateState state, bool validOldState, SpaceTimeCoordinateState oldState, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalEntityValueListener::Adapter::accelerationUpdated(HlaPhysicalEntityPtr physicalEntity, std::vector</* 3 */ double > acceleration, bool validOldAcceleration, std::vector</* 3 */ double > oldAcceleration, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalEntityValueListener::Adapter::rotationalAccelerationUpdated(HlaPhysicalEntityPtr physicalEntity, std::vector</* 3 */ double > rotationalAcceleration, bool validOldRotationalAcceleration, std::vector</* 3 */ double > oldRotationalAcceleration, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalEntityValueListener::Adapter::centerOfMassUpdated(HlaPhysicalEntityPtr physicalEntity, std::vector</* 3 */ double > centerOfMass, bool validOldCenterOfMass, std::vector</* 3 */ double > oldCenterOfMass, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalEntityValueListener::Adapter::bodyWrtStructuralUpdated(HlaPhysicalEntityPtr physicalEntity, AttitudeQuaternion bodyWrtStructural, bool validOldBodyWrtStructural, AttitudeQuaternion oldBodyWrtStructural, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

You may also implement the <code>HlaPhysicalEntityValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaPhysicalEntityListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaPhysicalEntityListener::attributesUpdated(HlaPhysicalEntityPtr physicalEntity, HlaEnumSet&lt;HlaPhysicalEntityAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of PhysicalEntity:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaPhysicalEntityManager()->createLocalHlaPhysicalEntity(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaPhysicalEntityManager()->createLocalHlaPhysicalEntity(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaPhysicalEntityUpdater</code> as follows:

<blockquote><pre>
HlaPhysicalEntityUpdaterPtr updater = myInstance->getHlaPhysicalEntityUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>DynamicalEntity Class</h3>


<h4>Working with DynamicalEntity Instances</h4>

To work with DynamicalEntity you first need to get the <code>HlaDynamicalEntityManager</code> instance which is
available through the <code>HlaWorld->getHlaDynamicalEntityManager</code> method.
<p>

To work with object instances you may use the <code>HlaDynamicalEntityManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaDynamicalEntityManagerPtr dynamicalEntitymanager = world->getHlaDynamicalEntityManager();
dynamicalEntitymanager->getHlaDynamicalEntitys();
dynamicalEntitymanager->getLocalHlaDynamicalEntitys();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
dynamicalEntityManager->getDynamicalEntityByHlaInstanceName(const std::wstring& hlaInstanceName)
dynamicalEntityManager->getDynamicalEntityByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each DynamicalEntity attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
bool hasForce();
std::vector</* 3 */ double > getForce();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getForceTimeStamped();

bool hasTorque();
std::vector</* 3 */ double > getTorque();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getTorqueTimeStamped();

bool hasMass();
double getMass();
HlaTimeStamped&lt; double > getMassTimeStamped();

bool hasMassRate();
double getMassRate();
HlaTimeStamped&lt; double > getMassRateTimeStamped();

bool hasInertia();
std::vector</* 9 */ double > getInertia();
HlaTimeStamped&lt; std::vector</* 9 */ double > > getInertiaTimeStamped();

bool hasInertiaRate();
std::vector</* 9 */ double > getInertiaRate();
HlaTimeStamped&lt; std::vector</* 9 */ double > > getInertiaRateTimeStamped();

bool hasName();
std::wstring getName();
HlaTimeStamped&lt; std::wstring > getNameTimeStamped();

bool hasType();
std::wstring getType();
HlaTimeStamped&lt; std::wstring > getTypeTimeStamped();

bool hasStatus();
std::wstring getStatus();
HlaTimeStamped&lt; std::wstring > getStatusTimeStamped();

bool hasParentReferenceFrame();
std::wstring getParentReferenceFrame();
HlaTimeStamped&lt; std::wstring > getParentReferenceFrameTimeStamped();

bool hasState();
SpaceTimeCoordinateState getState();
HlaTimeStamped&lt; SpaceTimeCoordinateState > getStateTimeStamped();

bool hasAcceleration();
std::vector</* 3 */ double > getAcceleration();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getAccelerationTimeStamped();

bool hasRotationalAcceleration();
std::vector</* 3 */ double > getRotationalAcceleration();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getRotationalAccelerationTimeStamped();

bool hasCenterOfMass();
std::vector</* 3 */ double > getCenterOfMass();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getCenterOfMassTimeStamped();

bool hasBodyWrtStructural();
AttitudeQuaternion getBodyWrtStructural();
HlaTimeStamped&lt; AttitudeQuaternion > getBodyWrtStructuralTimeStamped();

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaDynamicalEntity->getHlaDynamicalEntityAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaDynamicalEntityValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaDynamicalEntityValueListener::Adapter::forceUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::vector</* 3 */ double > force, bool validOldForce, std::vector</* 3 */ double > oldForce, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::torqueUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::vector</* 3 */ double > torque, bool validOldTorque, std::vector</* 3 */ double > oldTorque, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::massUpdated(HlaDynamicalEntityPtr dynamicalEntity, double mass, bool validOldMass, double oldMass, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::massRateUpdated(HlaDynamicalEntityPtr dynamicalEntity, double massRate, bool validOldMassRate, double oldMassRate, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::inertiaUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::vector</* 9 */ double > inertia, bool validOldInertia, std::vector</* 9 */ double > oldInertia, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::inertiaRateUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::vector</* 9 */ double > inertiaRate, bool validOldInertiaRate, std::vector</* 9 */ double > oldInertiaRate, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::nameUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::wstring name, bool validOldName, std::wstring oldName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::typeUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::wstring type, bool validOldType, std::wstring oldType, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::statusUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::wstring status, bool validOldStatus, std::wstring oldStatus, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::parentReferenceFrameUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::wstring parentReferenceFrame, bool validOldParentReferenceFrame, std::wstring oldParentReferenceFrame, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::stateUpdated(HlaDynamicalEntityPtr dynamicalEntity, SpaceTimeCoordinateState state, bool validOldState, SpaceTimeCoordinateState oldState, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::accelerationUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::vector</* 3 */ double > acceleration, bool validOldAcceleration, std::vector</* 3 */ double > oldAcceleration, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::rotationalAccelerationUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::vector</* 3 */ double > rotationalAcceleration, bool validOldRotationalAcceleration, std::vector</* 3 */ double > oldRotationalAcceleration, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::centerOfMassUpdated(HlaDynamicalEntityPtr dynamicalEntity, std::vector</* 3 */ double > centerOfMass, bool validOldCenterOfMass, std::vector</* 3 */ double > oldCenterOfMass, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaDynamicalEntityValueListener::Adapter::bodyWrtStructuralUpdated(HlaDynamicalEntityPtr dynamicalEntity, AttitudeQuaternion bodyWrtStructural, bool validOldBodyWrtStructural, AttitudeQuaternion oldBodyWrtStructural, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

You may also implement the <code>HlaDynamicalEntityValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaDynamicalEntityListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaDynamicalEntityListener::attributesUpdated(HlaDynamicalEntityPtr dynamicalEntity, HlaEnumSet&lt;HlaDynamicalEntityAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of DynamicalEntity:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaDynamicalEntityManager()->createLocalHlaDynamicalEntity(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaDynamicalEntityManager()->createLocalHlaDynamicalEntity(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaDynamicalEntityUpdater</code> as follows:

<blockquote><pre>
HlaDynamicalEntityUpdaterPtr updater = myInstance->getHlaDynamicalEntityUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>Payload Class</h3>


<h4>Working with Payload Instances</h4>

To work with Payload you first need to get the <code>HlaPayloadManager</code> instance which is
available through the <code>HlaWorld->getHlaPayloadManager</code> method.
<p>

To work with object instances you may use the <code>HlaPayloadManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaPayloadManagerPtr payloadmanager = world->getHlaPayloadManager();
payloadmanager->getHlaPayloads();
payloadmanager->getLocalHlaPayloads();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
payloadManager->getPayloadByHlaInstanceName(const std::wstring& hlaInstanceName)
payloadManager->getPayloadByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each Payload attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
bool hasPosition();
std::vector</* 3 */ double > getPosition();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getPositionTimeStamped();

bool hasVelocity();
std::vector</* 3 */ double > getVelocity();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getVelocityTimeStamped();

bool hasHealth();
double getHealth();
HlaTimeStamped&lt; double > getHealthTimeStamped();

bool hasForce();
std::vector</* 3 */ double > getForce();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getForceTimeStamped();

bool hasTorque();
std::vector</* 3 */ double > getTorque();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getTorqueTimeStamped();

bool hasMass();
double getMass();
HlaTimeStamped&lt; double > getMassTimeStamped();

bool hasMassRate();
double getMassRate();
HlaTimeStamped&lt; double > getMassRateTimeStamped();

bool hasInertia();
std::vector</* 9 */ double > getInertia();
HlaTimeStamped&lt; std::vector</* 9 */ double > > getInertiaTimeStamped();

bool hasInertiaRate();
std::vector</* 9 */ double > getInertiaRate();
HlaTimeStamped&lt; std::vector</* 9 */ double > > getInertiaRateTimeStamped();

bool hasName();
std::wstring getName();
HlaTimeStamped&lt; std::wstring > getNameTimeStamped();

bool hasType();
std::wstring getType();
HlaTimeStamped&lt; std::wstring > getTypeTimeStamped();

bool hasStatus();
std::wstring getStatus();
HlaTimeStamped&lt; std::wstring > getStatusTimeStamped();

bool hasParentReferenceFrame();
std::wstring getParentReferenceFrame();
HlaTimeStamped&lt; std::wstring > getParentReferenceFrameTimeStamped();

bool hasState();
SpaceTimeCoordinateState getState();
HlaTimeStamped&lt; SpaceTimeCoordinateState > getStateTimeStamped();

bool hasAcceleration();
std::vector</* 3 */ double > getAcceleration();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getAccelerationTimeStamped();

bool hasRotationalAcceleration();
std::vector</* 3 */ double > getRotationalAcceleration();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getRotationalAccelerationTimeStamped();

bool hasCenterOfMass();
std::vector</* 3 */ double > getCenterOfMass();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getCenterOfMassTimeStamped();

bool hasBodyWrtStructural();
AttitudeQuaternion getBodyWrtStructural();
HlaTimeStamped&lt; AttitudeQuaternion > getBodyWrtStructuralTimeStamped();

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaPayload->getHlaPayloadAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaPayloadValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaPayloadValueListener::Adapter::positionUpdated(HlaPayloadPtr payload, std::vector</* 3 */ double > position, bool validOldPosition, std::vector</* 3 */ double > oldPosition, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::velocityUpdated(HlaPayloadPtr payload, std::vector</* 3 */ double > velocity, bool validOldVelocity, std::vector</* 3 */ double > oldVelocity, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::healthUpdated(HlaPayloadPtr payload, double health, bool validOldHealth, double oldHealth, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::forceUpdated(HlaPayloadPtr payload, std::vector</* 3 */ double > force, bool validOldForce, std::vector</* 3 */ double > oldForce, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::torqueUpdated(HlaPayloadPtr payload, std::vector</* 3 */ double > torque, bool validOldTorque, std::vector</* 3 */ double > oldTorque, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::massUpdated(HlaPayloadPtr payload, double mass, bool validOldMass, double oldMass, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::massRateUpdated(HlaPayloadPtr payload, double massRate, bool validOldMassRate, double oldMassRate, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::inertiaUpdated(HlaPayloadPtr payload, std::vector</* 9 */ double > inertia, bool validOldInertia, std::vector</* 9 */ double > oldInertia, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::inertiaRateUpdated(HlaPayloadPtr payload, std::vector</* 9 */ double > inertiaRate, bool validOldInertiaRate, std::vector</* 9 */ double > oldInertiaRate, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::nameUpdated(HlaPayloadPtr payload, std::wstring name, bool validOldName, std::wstring oldName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::typeUpdated(HlaPayloadPtr payload, std::wstring type, bool validOldType, std::wstring oldType, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::statusUpdated(HlaPayloadPtr payload, std::wstring status, bool validOldStatus, std::wstring oldStatus, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::parentReferenceFrameUpdated(HlaPayloadPtr payload, std::wstring parentReferenceFrame, bool validOldParentReferenceFrame, std::wstring oldParentReferenceFrame, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::stateUpdated(HlaPayloadPtr payload, SpaceTimeCoordinateState state, bool validOldState, SpaceTimeCoordinateState oldState, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::accelerationUpdated(HlaPayloadPtr payload, std::vector</* 3 */ double > acceleration, bool validOldAcceleration, std::vector</* 3 */ double > oldAcceleration, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::rotationalAccelerationUpdated(HlaPayloadPtr payload, std::vector</* 3 */ double > rotationalAcceleration, bool validOldRotationalAcceleration, std::vector</* 3 */ double > oldRotationalAcceleration, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::centerOfMassUpdated(HlaPayloadPtr payload, std::vector</* 3 */ double > centerOfMass, bool validOldCenterOfMass, std::vector</* 3 */ double > oldCenterOfMass, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPayloadValueListener::Adapter::bodyWrtStructuralUpdated(HlaPayloadPtr payload, AttitudeQuaternion bodyWrtStructural, bool validOldBodyWrtStructural, AttitudeQuaternion oldBodyWrtStructural, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

You may also implement the <code>HlaPayloadValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaPayloadListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaPayloadListener::attributesUpdated(HlaPayloadPtr payload, HlaEnumSet&lt;HlaPayloadAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of Payload:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaPayloadManager()->createLocalHlaPayload(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaPayloadManager()->createLocalHlaPayload(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaPayloadUpdater</code> as follows:

<blockquote><pre>
HlaPayloadUpdaterPtr updater = myInstance->getHlaPayloadUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>Launcher Class</h3>


<h4>Working with Launcher Instances</h4>

To work with Launcher you first need to get the <code>HlaLauncherManager</code> instance which is
available through the <code>HlaWorld->getHlaLauncherManager</code> method.
<p>

To work with object instances you may use the <code>HlaLauncherManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaLauncherManagerPtr launchermanager = world->getHlaLauncherManager();
launchermanager->getHlaLaunchers();
launchermanager->getLocalHlaLaunchers();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
launcherManager->getLauncherByHlaInstanceName(const std::wstring& hlaInstanceName)
launcherManager->getLauncherByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each Launcher attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
bool hasPosition();
std::vector</* 3 */ double > getPosition();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getPositionTimeStamped();

bool hasMass();
double getMass();
HlaTimeStamped&lt; double > getMassTimeStamped();

bool hasEnergy();
double getEnergy();
HlaTimeStamped&lt; double > getEnergyTimeStamped();

bool hasName();
std::wstring getName();
HlaTimeStamped&lt; std::wstring > getNameTimeStamped();

bool hasType();
std::wstring getType();
HlaTimeStamped&lt; std::wstring > getTypeTimeStamped();

bool hasStatus();
std::wstring getStatus();
HlaTimeStamped&lt; std::wstring > getStatusTimeStamped();

bool hasParentReferenceFrame();
std::wstring getParentReferenceFrame();
HlaTimeStamped&lt; std::wstring > getParentReferenceFrameTimeStamped();

bool hasState();
SpaceTimeCoordinateState getState();
HlaTimeStamped&lt; SpaceTimeCoordinateState > getStateTimeStamped();

bool hasAcceleration();
std::vector</* 3 */ double > getAcceleration();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getAccelerationTimeStamped();

bool hasRotationalAcceleration();
std::vector</* 3 */ double > getRotationalAcceleration();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getRotationalAccelerationTimeStamped();

bool hasCenterOfMass();
std::vector</* 3 */ double > getCenterOfMass();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getCenterOfMassTimeStamped();

bool hasBodyWrtStructural();
AttitudeQuaternion getBodyWrtStructural();
HlaTimeStamped&lt; AttitudeQuaternion > getBodyWrtStructuralTimeStamped();

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaLauncher->getHlaLauncherAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaLauncherValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaLauncherValueListener::Adapter::positionUpdated(HlaLauncherPtr launcher, std::vector</* 3 */ double > position, bool validOldPosition, std::vector</* 3 */ double > oldPosition, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::massUpdated(HlaLauncherPtr launcher, double mass, bool validOldMass, double oldMass, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::energyUpdated(HlaLauncherPtr launcher, double energy, bool validOldEnergy, double oldEnergy, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::nameUpdated(HlaLauncherPtr launcher, std::wstring name, bool validOldName, std::wstring oldName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::typeUpdated(HlaLauncherPtr launcher, std::wstring type, bool validOldType, std::wstring oldType, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::statusUpdated(HlaLauncherPtr launcher, std::wstring status, bool validOldStatus, std::wstring oldStatus, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::parentReferenceFrameUpdated(HlaLauncherPtr launcher, std::wstring parentReferenceFrame, bool validOldParentReferenceFrame, std::wstring oldParentReferenceFrame, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::stateUpdated(HlaLauncherPtr launcher, SpaceTimeCoordinateState state, bool validOldState, SpaceTimeCoordinateState oldState, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::accelerationUpdated(HlaLauncherPtr launcher, std::vector</* 3 */ double > acceleration, bool validOldAcceleration, std::vector</* 3 */ double > oldAcceleration, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::rotationalAccelerationUpdated(HlaLauncherPtr launcher, std::vector</* 3 */ double > rotationalAcceleration, bool validOldRotationalAcceleration, std::vector</* 3 */ double > oldRotationalAcceleration, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::centerOfMassUpdated(HlaLauncherPtr launcher, std::vector</* 3 */ double > centerOfMass, bool validOldCenterOfMass, std::vector</* 3 */ double > oldCenterOfMass, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaLauncherValueListener::Adapter::bodyWrtStructuralUpdated(HlaLauncherPtr launcher, AttitudeQuaternion bodyWrtStructural, bool validOldBodyWrtStructural, AttitudeQuaternion oldBodyWrtStructural, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

You may also implement the <code>HlaLauncherValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaLauncherListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaLauncherListener::attributesUpdated(HlaLauncherPtr launcher, HlaEnumSet&lt;HlaLauncherAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of Launcher:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaLauncherManager()->createLocalHlaLauncher(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaLauncherManager()->createLocalHlaLauncher(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaLauncherUpdater</code> as follows:

<blockquote><pre>
HlaLauncherUpdaterPtr updater = myInstance->getHlaLauncherUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>PhysicalInterface Class</h3>


<h4>Working with PhysicalInterface Instances</h4>

To work with PhysicalInterface you first need to get the <code>HlaPhysicalInterfaceManager</code> instance which is
available through the <code>HlaWorld->getHlaPhysicalInterfaceManager</code> method.
<p>

To work with object instances you may use the <code>HlaPhysicalInterfaceManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaPhysicalInterfaceManagerPtr physicalInterfacemanager = world->getHlaPhysicalInterfaceManager();
physicalInterfacemanager->getHlaPhysicalInterfaces();
physicalInterfacemanager->getLocalHlaPhysicalInterfaces();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
physicalInterfaceManager->getPhysicalInterfaceByHlaInstanceName(const std::wstring& hlaInstanceName)
physicalInterfaceManager->getPhysicalInterfaceByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each PhysicalInterface attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
bool hasName();
std::wstring getName();
HlaTimeStamped&lt; std::wstring > getNameTimeStamped();

bool hasParentName();
std::wstring getParentName();
HlaTimeStamped&lt; std::wstring > getParentNameTimeStamped();

bool hasPosition();
std::vector</* 3 */ double > getPosition();
HlaTimeStamped&lt; std::vector</* 3 */ double > > getPositionTimeStamped();

bool hasAttitude();
AttitudeQuaternion getAttitude();
HlaTimeStamped&lt; AttitudeQuaternion > getAttitudeTimeStamped();

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaPhysicalInterface->getHlaPhysicalInterfaceAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaPhysicalInterfaceValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaPhysicalInterfaceValueListener::Adapter::nameUpdated(HlaPhysicalInterfacePtr physicalInterface, std::wstring name, bool validOldName, std::wstring oldName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalInterfaceValueListener::Adapter::parentNameUpdated(HlaPhysicalInterfacePtr physicalInterface, std::wstring parentName, bool validOldParentName, std::wstring oldParentName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalInterfaceValueListener::Adapter::positionUpdated(HlaPhysicalInterfacePtr physicalInterface, std::vector</* 3 */ double > position, bool validOldPosition, std::vector</* 3 */ double > oldPosition, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaPhysicalInterfaceValueListener::Adapter::attitudeUpdated(HlaPhysicalInterfacePtr physicalInterface, AttitudeQuaternion attitude, bool validOldAttitude, AttitudeQuaternion oldAttitude, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

You may also implement the <code>HlaPhysicalInterfaceValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaPhysicalInterfaceListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaPhysicalInterfaceListener::attributesUpdated(HlaPhysicalInterfacePtr physicalInterface, HlaEnumSet&lt;HlaPhysicalInterfaceAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of PhysicalInterface:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaPhysicalInterfaceManager()->createLocalHlaPhysicalInterface(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaPhysicalInterfaceManager()->createLocalHlaPhysicalInterface(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaPhysicalInterfaceUpdater</code> as follows:

<blockquote><pre>
HlaPhysicalInterfaceUpdaterPtr updater = myInstance->getHlaPhysicalInterfaceUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>ReferenceFrame Class</h3>


<h4>Working with ReferenceFrame Instances</h4>

To work with ReferenceFrame you first need to get the <code>HlaReferenceFrameManager</code> instance which is
available through the <code>HlaWorld->getHlaReferenceFrameManager</code> method.
<p>

To work with object instances you may use the <code>HlaReferenceFrameManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaReferenceFrameManagerPtr referenceFramemanager = world->getHlaReferenceFrameManager();
referenceFramemanager->getHlaReferenceFrames();
referenceFramemanager->getLocalHlaReferenceFrames();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
referenceFrameManager->getReferenceFrameByHlaInstanceName(const std::wstring& hlaInstanceName)
referenceFrameManager->getReferenceFrameByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each ReferenceFrame attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
bool hasName();
std::wstring getName();
HlaTimeStamped&lt; std::wstring > getNameTimeStamped();

bool hasParentName();
std::wstring getParentName();
HlaTimeStamped&lt; std::wstring > getParentNameTimeStamped();

bool hasState();
SpaceTimeCoordinateState getState();
HlaTimeStamped&lt; SpaceTimeCoordinateState > getStateTimeStamped();

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaReferenceFrame->getHlaReferenceFrameAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaReferenceFrameValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaReferenceFrameValueListener::Adapter::nameUpdated(HlaReferenceFramePtr referenceFrame, std::wstring name, bool validOldName, std::wstring oldName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaReferenceFrameValueListener::Adapter::parentNameUpdated(HlaReferenceFramePtr referenceFrame, std::wstring parentName, bool validOldParentName, std::wstring oldParentName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaReferenceFrameValueListener::Adapter::stateUpdated(HlaReferenceFramePtr referenceFrame, SpaceTimeCoordinateState state, bool validOldState, SpaceTimeCoordinateState oldState, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

You may also implement the <code>HlaReferenceFrameValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaReferenceFrameListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaReferenceFrameListener::attributesUpdated(HlaReferenceFramePtr referenceFrame, HlaEnumSet&lt;HlaReferenceFrameAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of ReferenceFrame:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaReferenceFrameManager()->createLocalHlaReferenceFrame(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaReferenceFrameManager()->createLocalHlaReferenceFrame(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaReferenceFrameUpdater</code> as follows:

<blockquote><pre>
HlaReferenceFrameUpdaterPtr updater = myInstance->getHlaReferenceFrameUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>Moon Class</h3>


<h4>Working with Moon Instances</h4>

To work with Moon you first need to get the <code>HlaMoonManager</code> instance which is
available through the <code>HlaWorld->getHlaMoonManager</code> method.
<p>

To work with object instances you may use the <code>HlaMoonManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaMoonManagerPtr moonmanager = world->getHlaMoonManager();
moonmanager->getHlaMoons();
moonmanager->getLocalHlaMoons();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
moonManager->getMoonByHlaInstanceName(const std::wstring& hlaInstanceName)
moonManager->getMoonByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each Moon attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
bool hasName();
std::wstring getName();
HlaTimeStamped&lt; std::wstring > getNameTimeStamped();

bool hasParentName();
std::wstring getParentName();
HlaTimeStamped&lt; std::wstring > getParentNameTimeStamped();

bool hasState();
SpaceTimeCoordinateState getState();
HlaTimeStamped&lt; SpaceTimeCoordinateState > getStateTimeStamped();

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaMoon->getHlaMoonAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaMoonValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaMoonValueListener::Adapter::nameUpdated(HlaMoonPtr moon, std::wstring name, bool validOldName, std::wstring oldName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaMoonValueListener::Adapter::parentNameUpdated(HlaMoonPtr moon, std::wstring parentName, bool validOldParentName, std::wstring oldParentName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaMoonValueListener::Adapter::stateUpdated(HlaMoonPtr moon, SpaceTimeCoordinateState state, bool validOldState, SpaceTimeCoordinateState oldState, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

You may also implement the <code>HlaMoonValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaMoonListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaMoonListener::attributesUpdated(HlaMoonPtr moon, HlaEnumSet&lt;HlaMoonAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of Moon:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaMoonManager()->createLocalHlaMoon(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaMoonManager()->createLocalHlaMoon(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaMoonUpdater</code> as follows:

<blockquote><pre>
HlaMoonUpdaterPtr updater = myInstance->getHlaMoonUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>ExecutionConfiguration Class</h3>


<h4>Working with ExecutionConfiguration Instances</h4>

To work with ExecutionConfiguration you first need to get the <code>HlaExecutionConfigurationManager</code> instance which is
available through the <code>HlaWorld->getHlaExecutionConfigurationManager</code> method.
<p>

To work with object instances you may use the <code>HlaExecutionConfigurationManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->connect();
HlaExecutionConfigurationManagerPtr executionConfigurationmanager = world->getHlaExecutionConfigurationManager();
executionConfigurationmanager->getHlaExecutionConfigurations();
executionConfigurationmanager->getLocalHlaExecutionConfigurations();
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
executionConfigurationManager->getExecutionConfigurationByHlaInstanceName(const std::wstring& hlaInstanceName)
executionConfigurationManager->getExecutionConfigurationByHlaInstanceHandle(const std::vector<char>& encodedHlaInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each ExecutionConfiguration attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
bool hasRootFrameName();
std::wstring getRootFrameName();
HlaTimeStamped&lt; std::wstring > getRootFrameNameTimeStamped();

bool hasScenarioTimeEpoch();
double getScenarioTimeEpoch();
HlaTimeStamped&lt; double > getScenarioTimeEpochTimeStamped();

bool hasCurrentExecutionMode();
ExecutionMode getCurrentExecutionMode();
HlaTimeStamped&lt; ExecutionMode > getCurrentExecutionModeTimeStamped();

bool hasNextExecutionMode();
ExecutionMode getNextExecutionMode();
HlaTimeStamped&lt; ExecutionMode > getNextExecutionModeTimeStamped();

bool hasNextModeScenarioTime();
double getNextModeScenarioTime();
HlaTimeStamped&lt; double > getNextModeScenarioTimeTimeStamped();

bool hasNextModeCteTime();
double getNextModeCteTime();
HlaTimeStamped&lt; double > getNextModeCteTimeTimeStamped();

bool hasLeastCommonTimeStep();
long long getLeastCommonTimeStep();
HlaTimeStamped&lt; long long > getLeastCommonTimeStepTimeStamped();

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaExecutionConfiguration->getHlaExecutionConfigurationAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaExecutionConfigurationValueListener::Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaExecutionConfigurationValueListener::Adapter::rootFrameNameUpdated(HlaExecutionConfigurationPtr executionConfiguration, std::wstring rootFrameName, bool validOldRootFrameName, std::wstring oldRootFrameName, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaExecutionConfigurationValueListener::Adapter::scenarioTimeEpochUpdated(HlaExecutionConfigurationPtr executionConfiguration, double scenarioTimeEpoch, bool validOldScenarioTimeEpoch, double oldScenarioTimeEpoch, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaExecutionConfigurationValueListener::Adapter::currentExecutionModeUpdated(HlaExecutionConfigurationPtr executionConfiguration, ExecutionMode::ExecutionMode currentExecutionMode, bool validOldCurrentExecutionMode, ExecutionMode::ExecutionMode oldCurrentExecutionMode, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaExecutionConfigurationValueListener::Adapter::nextExecutionModeUpdated(HlaExecutionConfigurationPtr executionConfiguration, ExecutionMode::ExecutionMode nextExecutionMode, bool validOldNextExecutionMode, ExecutionMode::ExecutionMode oldNextExecutionMode, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaExecutionConfigurationValueListener::Adapter::nextModeScenarioTimeUpdated(HlaExecutionConfigurationPtr executionConfiguration, double nextModeScenarioTime, bool validOldNextModeScenarioTime, double oldNextModeScenarioTime, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaExecutionConfigurationValueListener::Adapter::nextModeCteTimeUpdated(HlaExecutionConfigurationPtr executionConfiguration, double nextModeCteTime, bool validOldNextModeCteTime, double oldNextModeCteTime, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
HlaExecutionConfigurationValueListener::Adapter::leastCommonTimeStepUpdated(HlaExecutionConfigurationPtr executionConfiguration, long long leastCommonTimeStep, bool validOldLeastCommonTimeStep, long long oldLeastCommonTimeStep, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>

You may also implement the <code>HlaExecutionConfigurationValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaExecutionConfigurationListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaExecutionConfigurationListener::attributesUpdated(HlaExecutionConfigurationPtr executionConfiguration, HlaEnumSet&lt;HlaExecutionConfigurationAttributes::Attribute&gt; &attributes, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of ExecutionConfiguration:

<blockquote><pre>
HlaWorldPtr world = HlaWorld::Factory::create();
world->getHlaExecutionConfigurationManager()->createLocalHlaExecutionConfiguration(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
world->getHlaExecutionConfigurationManager()->createLocalHlaExecutionConfiguration(
    const std::wstring& hlaInstanceName
    )
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaExecutionConfigurationUpdater</code> as follows:

<blockquote><pre>
HlaExecutionConfigurationUpdaterPtr updater = myInstance->getHlaExecutionConfigurationUpdater();

updater->set<i>AttributeName</i>(<i>new attribute value</i>);
updater->set<i>AttributeName</i>(<i>new attribute value</i>);

updater->sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.





<h2>Using Time Management</h2>

When calling <code>_hlaWorld->connect()</code> time management will be enabled according to the settings in the <code>HlaSettings</code> that
was supplied when creating the <code>HlaWorld</code> object, or the default values if no <code>HlaSettings</code> was supplied.
<p>
There are three different methods available to advance the logical time of your federate. They are available in the
<code>HlaWorld</code> interface and each method has a slightly different use case as described below. All three functions
will not return until the RTI has granted the federate a new logical time. This means that depending on how other federates
uses time management, your federate might have to wait until other federates have advanced their logical time.

<h3>Advance to Next Frame</h3>

<blockquote><pre>
_hlaWorld->advanceToNextFrame();
</pre></blockquote>

This method should be used when your federate is frame based. It will use the value you selected for step size and try to advance the logical time
of the federate to the federates current logical time + step size.
<p>
<i>Example</i>: A federate with a step size of <code>5</code> would move its logical time as follows: <code>0, 5, 10, 15, ...</code>
<p>
If the federate is frame based with an update rate of 10Hz, <code>advanceToNextFrame()</code> should be called 10 times each second.

<h3>Advance to Next Event</h3>

<blockquote><pre>
_hlaWorld->advanceToNextEvent();
</pre></blockquote>

This method should be used when your federate is event based. It will try to advance the logical time of the federate to the logical time of the next
event it is going to receive, or if there is no event available, to the federates current logical time + step size. The <code>advanceToNextEvent()</code>
function supports a zero lookahead.
<p>
<i>Example</i>: A federate with a step size of <code>5</code> that receives events at time <code>7</code> and <code>16</code> would move
its logical time as follows: <code>0, 5, 7, 12, 16, 21, ...</code>
<p>
Set your step size to a very large value to only be granted to a logical time if there is an event available.

<h3>Advance to Logical Time</h3>
<blockquote><pre>
HlaLogicalTimePtr newLogicalTime(_hlaWorld->createLogicalTime(100));
_hlaWorld->advanceToLogicalTime(newLogicalTime);
</pre></blockquote>
This method should be used if you want to move the federates logical time to a specific logical time.
<p>
<i>Example</i>: A frame based federate with step size of <code>2</code> which makes a <code>advanceToNextLogicalTime(100)</code> at logical time
<code>10</code> would move its logical time as follows: <code>0, 2, 4, 6, 8, 10, 100, 102, 104, ...</code>

<h3>Default Send Time</h3>

If an update is sent without a specified logical time the default send time will be used.

<blockquote><pre>
updater->sendUpdate() // default send time will be used

HlaLogicalTimePtr logicalTime(_world->createLogicalTime(100));
updater->sendUpdate(logicalTime) // specified logical time will be used
</pre></blockquote>

The default send time of the federate is the federates current logical time plus the lookahead. It is impossible to send an update with a specified
logical time that is lower than the default send time.

A default send time will be used when:
<ul>
   <li>Sending an update</li>
   <li>Sending an interaction</li>
   <li>Deleting an object</li>
</ul>

When creating a frame based federate lookahead will normally be the same as the step size, that way the default send time will be the logical time of the next frame.

<h3>Changing Step Size and Lookahead</h3>

Step size and lookahead can be changed at runtime using <code>HlaSettings</code>. After advancing the time, using any of the methods above,
<code>getStepSize</code> and <code>getLookahead</code> will be called and step size and lookahead will be updated accordingly.

<blockquote><pre>
// federate moves its logical time: 0, 1, 2, 3, 4,
_hlaWorld->getSettings()->setStepSize(2);
_hlaWorld->getSettings()->setLookahead(2);
// 5, 7, 9, ...
</pre></blockquote>

<h3>Invoke When Granted</h3>

When calling any of the three methods above to advance the time the federate will move into what is call the <i>advancing state</i>. After returning
the federate is in the <i>granted state</i>. It is during the <i>advancing state</i> the federate will receive time stamped messages from other federates.
<code>invokeWhenGranted</code> can be used to call a method when the federate has moved to the <i>granted state</i> with the additional guarantee that all listeners has been
called before executing the method.

<blockquote><pre>
void calculateNextState();

// inside a listener calculateNextState is posted to invokeWhenGranted
void positionUpdated(HlaAircraftPtr aircraft, PositionRec position, ...) {
   _myAircraft->setPosition(position);
   _hlaWorld->invokeWhenGranted(&calculateNextState);
}
// more listeners for speed, altitude and so on...

/*
 * calculateNextState will not be called until all listeners has been called,
 * guaranteeing that myAircraft has been completely updated.
 */
</pre></blockquote>

<h3>Save and Restore</h3>

Support for HLA Save and Restore are available in the <code>HlaSaveRestoreManager</code>.
Limitations in the current implementation:
<ul>
    <li>Instances can not be saved. If the <code>HlaWorld</code> has any
        local or remote instances the save will fail.</li>
    <li>Save and restore can only be performed within the same federation,
         it is not possible to save, resign, join a new federation and then restore.</li>
</ul>

It is expected that users of HLA Time Management might want to use this save and restore functionality
to restore the logical time, for example when doing Monte Carlo style simulations.
<p>
Read more in the <code>HlaSaveRestoreManager</code> documentation.


<h2>Working with Complex FOM Data types</h2>

FOM data types are converted to native C++ types if it is possible. For example is the FOM
data type <code>HLAunicodeString</code> handled as a <code>std::string</code>.
The table below lists FOM data types.
<br>
<table>
    <thead>
        <tr>
            <th>FOM Data type</th>
            <th>Example</th>
            <th>C++ type</th>
            <th>Example</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td>Array</td>
            <td><code>HLAopaqueData</code></td>
            <td>std::vector of the element type</td>
            <td><code>std::vector&lt;char&gt;</code></td>
        </tr>

        <tr>
            <td>Basic</td>
            <td><code>HLAfloat64BE</code></td>
            <td>Native C++ type</td>
            <td><code>double</code></td>
        </tr>

        <tr>
            <td>Enumerated</td>
            <td><code>HLAswitch</code></td>
            <td>C++ enum</td>
            <td><code>HLAswitch</code></td>
        </tr>

        <tr>
            <td>Fixed Record</td>
            <td><code>VelocityVector</code></td>
            <td>C++ class</td>
            <td><code>VelocityVector</code></td>
        </tr>

        <tr>
            <td>Simple</td>
            <td><code>HLAbyte</code></td>
            <td>Same as Basic type</td>
            <td><code>byte</code></td>
        </tr>

        <tr>
            <td>Variant Record</td>
            <td><code>Spatial</code></td>
            <td>C++ class</td>
            <td><code>Spatial</code></td>
        </tr>
    </tbody>
</table>


<h3>Arrays</h3>

The following encodings are supported:
<ul>
    <li><code>HLAlengthlessVarArray</code> and <code>RPRlengthlessArray</code></li>
    <li><code>HLAunpaddedLengthlessVarArray</code> and <code>RPRunpaddedLengthlessArray</code></li>
    <li><code>HLAvariableArray</code></li>
    <li><code>HLApaddingTo16Array</code> and <code>RPRpaddingTo16Array</code></li>
    <li><code>HLApaddingTo32Array</code> and <code>RPRpaddingTo32Array</code></li>
    <li><code>HLApaddingTo64Array</code> and <code>RPRpaddingTo64Array</code></li>
    <li><code>HLAnullTerminatedArray</code> and <code>RPRnullTerminatedArray</code>, with <code>HLAASCIIchar</code> elements</li>
    <li><code>HLAfixedArray</code>, with a fixed cardinality</li>
</ul>

All <code>HLAvariableArrays</code> with element type <code>HLAASCIIchar</code> or <code>HLAunicodeChar</code>
are converted to C++ <code>std::string</code>s or <code>std::wstring</code>s.
How different data types are converted is described in the table below.
<br>
<h3>Basic</h3>

<table>
<thead>
    <tr>
        <th>Basic FOM data type</th>
        <th>C++ data type</th>
    </tr>
</thead>

<tbody>
    <tr>
        <td><code>HLAoctet</code></td>
        <td><code>char</code></td>
    </tr>

    <tr>
        <td><code>HLAoctetPairBE</code></td>
        <td><code>std::pair&lt;char, char&gt; or wchar_t</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger16BE </code></td>
        <td><code>short</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger16LE</code></td>
        <td><code>short</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger32BE</code></td>
        <td><code>int</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger32LE</code></td>
        <td><code>int</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger64BE</code></td>
        <td><code>long long</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger64LE</code></td>
        <td><code>long long</code></td>
    </tr>

    <tr>
        <td><code>HLAfloat32BE</code></td>
        <td><code>float</code></td>
    </tr>

    <tr>
        <td><code>HLAfloat32LE</code></td>
        <td><code>float</code></td>
    </tr>

    <tr>
        <td><code>HLAfloat64BE</code></td>
        <td><code>double</code></td>
    </tr>

    <tr>
        <td><code>HLAfloat64LE</code></td>
        <td><code>double</code></td>
    </tr>

    <tr>
        <td><code>UnsignedShort</code></td>
        <td><code>unsigned short</code></td>
    </tr>

    <tr>
        <td><code>UnsignedInteger16BE</code></td>
        <td><code>unsigned short</code></td>
    </tr>

    <tr>
        <td><code>UnsignedInteger32BE</code></td>
        <td><code>unsigned int</code></td>
    </tr>

    <tr>
        <td><code>UnsignedInteger64BE</code></td>
        <td><code>unsigned long long</code></td>
    </tr>

    <tr>
        <td><code>RPRunsignedInteger8BE</code></td>
        <td><code>char</code></td>
    </tr>

    <tr>
        <td><code>RPRunsignedInteger16BE</code></td>
        <td><code>unsigned short</code></td>
    </tr>

    <tr>
        <td><code>RPRunsignedInteger32BE</code></td>
        <td><code>unsigned int</code></td>
    </tr>

    <tr>
        <td><code>RPRunsignedInteger64BE</code></td>
        <td><code>unsigned long long</code></td>
    </tr>
</tbody>
</table>


<h3>Enumerated</h3>

<code>HLAboolean</code>, <code>OMT13boolean</code> and <code>RPRboolean</code> are converted to native C++ bool, other enumerated data
types are converted to C++ <code>enum</code>s:

<blockquote><pre>
AirLineEnum::SAS
</pre></blockquote>


<h3>Fixed Record</h3>

Fixed records are converted to C++ classes with getters for each field and a public constructor.
Basic functions like <code>operator ==</code> and <code>operator &lt;&lt;</code> are supported.

<blockquote><pre>
long latitude = 1;
long longitude = 20;
long altitude = 300;
PositionRec position(latitude, longitude, altitude);
position.getLatitude();
position.getLongitude();
position.getAltitude();

PositionRec(1, 2, 3) == PositionRec(1, 2, 3)  // true
</pre></blockquote>


<h3>Simple</h3>

Simple types are the same as their basic type.


<h3>Variant Record</h3>

Variant record are handled in the same way as Fixed record but <code>getDiscriminant()</code> can be used
to get the alternative of the instance and there is a specific create method for each alternative.
Alternatives with ranges are not supported.


<h2>More about Process Models</h2>

<h3>Auto Evoke Mode</h3>
All notifications for this HlaWorld instance will be delivered in the same thread, a thread that is created
by HlaWorld. The notifications will be delivered automatically, as fast as possible. No need to call any
<code>evoke</code> methods.
<p>

It is possible to disable automatic invocations of notifications with the <code>disableNotifications</code>.
No <i>new</i> notifications will be invoked after <code>disableNotifications()</code> has <i>returned</i>.
<p>

Note that notifications has to be manually enabled once disabled.

If this HlaWorld is in manual evoke mode, these methods will be a no op.


<h3>Manual Evoke Mode</h3>
In this mode notifications will be delivered when one of the <code>evoke</code> methods are called. The notification is
delivered in the same thread that makes the call to the notification method.
Note that the HlaWorld will be updated asynchronously, without the need for any <code>evoke</code> calls.
<p>

To process the notification one of the three <code>evoke</code> methods should be used:

<blockquote><pre>
hlaWorld->evoke();           //evoke one notification
hlaWorld->evokeAll();        //evoke all notifications
hlaWorld->evokeAll(1000);    //evoke notifications during 1000 ms
</pre></blockquote>

<dl>
    <dt>
        <code>void evoke()</code>
    </dt>
    <dd>
        Evokes a single notification from the notification queue. The notification will be called from this thread.
        This method will return after the notification has returned. If there are no pending notifications,
        this method will return immediately.
        <p>

        If this HlaWorld is in auto evoke mode, this method will be a no op.
        <p>

        Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    </dd>

    <dt>
        <code>void evokeAll()</code>
    </dt>
    <dd>
        Evokes all pending notifications from the notification queue. The notifications will be called from this
        thread, one at a time. This method returns when the notification queue is empty.
        <p>

        If this HlaWorld is in auto evoke mode, this method will be a no op.
        <p>

        Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    </dd>

    <dt>
        <code>void evokeAll(unsigned long long millis)</code>
    </dt>
    <dd>
        Evokes notifications for at least <code>millis</code> milliseconds with this thread.
        If all pending notifications are processed before <code>millis</code> milliseconds have elapsed,
        the current thread is suspended until either some more notifications arrive, or the time has elapsed.
        <p>

        Note that this method could return even when there are pending notifications left.
        <p>

        If this HlaWorld is in auto evoke mode, this will suspend the current thread until the time has elapsed.

        Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    </dd>
</dl>

It is possible to check the number of pending notifications with the <code>peek</code> method

<blockquote><pre>
int pending = hlaWorld->peek();
</pre></blockquote>


<h2>Handling Exceptions</h2>

All exceptions are subclasses of <code>HlaException</code>.

<h3>HlaException</h3>

<table>
<thead>
    <tr>
        <th>Exception</th>
        <th>Description</th>
    </tr>
</thead>

<tbody>
    <tr>
        <td><code>HlaAttributeAlreadyOwnedException</code></td>
        <td>The federate tried to cancel acquire ownership of an attribute is has already received ownership of</td>
    </tr>

    <tr>
        <td><code>HlaAttributeNotOwnedException</code></td>
        <td>The attribute failed to be updated due to lacking ownership</td>
    </tr>

    <tr>
        <td><code>HlaConnectException</code></td>
        <td>The connection to the RTI failed</td>
    </tr>

    <tr>
        <td><code>HlaFederateNotAcquiringAttributeException</code></td>
        <td>The federate tried to cancel acquire ownership of an attribute it is not currently trying to acquire ownership of</td>
    </tr>

    <tr>
        <td><code>HlaDecodeException</code></td>
        <td>The attribute or parameter could not be decoded</td>
    </tr>

    <tr>
        <td><code>HlaEncodeException</code></td>
        <td>The attribute or parameter could not be encoded</td>
    </tr>

    <tr>
        <td><code>HlaFomException</code></td>
        <td>The FOM does not match the FOM used to for code generation</td>
    </tr>

    <tr>
        <td><code>HlaIllegalInstanceNameException</code></td>
        <td>The requested <i>HLA instance name</i> is illegal</td>
    </tr>

    <tr>
        <td><code>HlaInstanceNameInUseException</code></td>
        <td>The requested <i>HLA instance name</i> is already in use</td>
    </tr>

    <tr>
        <td><code>HlaInternalException</code></td>
        <td>An internal error occurred</td>
    </tr>

    <tr>
        <td><code>HlaNotConnectedException</code></td>
        <td>Not connected to the RTI and joined to the federation</td>
    </tr>

    <tr>
        <td><code>HlaRtiException</code></td>
        <td>The RTI operation failed, for example <i>RTI internal error</i></td>
    </tr>

    <tr>
        <td><code>HlaUpdaterReusedException</code></td>
        <td>An updater was reused</td>
    </tr>
    <tr>
        <td><code>HlaValueNotSetException</code></td>
        <td>The attribute has no value</td>
    </tr>
    <tr>
        <td><code>HlaObjectInstanceIsRemovedException</code></td>
        <td>The object has been removed</td>
    </tr>
    <tr>
        <td><code>HlaFederateOwnsAttributeException</code></td>
        <td>Unable to acquire an attribute, the attribute is already owned.
            Ownership acquisitions are pending or attributes are owned
            and this not handled by the resign action when disconnecting.</td>
    </tr>
    <tr>
        <td><code>HlaIncompatibleHlaVersionException</code></td>
        <td>The currently used HLA version can't support the called method</td>
    </tr>
    <tr>
        <td><code>HlaInvalidLicenseException</code></td>
        <td>The license is not valid</td>
    </tr>
    <tr>
        <td><code>HlaInTimeAdvancingStateException</code></td>
        <td>The operation cannot be performed in the time advancing state</td>
    </tr>
    <tr>
        <td><code>HlaInvalidLogicalTimeException</code></td>
        <td>The logical time is invalid or cannot be used</td>
    </tr>
    <tr>
        <td><code>HlaSaveFederateException </code></td>
        <td>The save operation failed</td>
    </tr>
    <tr>
        <td><code>HlaRestoreFederateException </code></td>
        <td>The restore operation failed</td>
    </tr>
    <tr>
        <td><code>HlaSaveInProgressException</code></td>
        <td>The save operation is in progress</td>
    </tr>
    <tr>
        <td><code>HlaRestoreInProgressException</code></td>
        <td>The restore operation is in progress</td>
    </tr>
    <tr>
        <td><code>HlaInvalidInterestException</code></td>
        <td>The interest is not valid</td>
    </tr>
    <tr>
        <td><code>HlaNormalizerException</code></td>
        <td>The normalizer is not set, or could not be set correctly</td>
    </tr>
</tbody>
</table>

<h3>Asynchronous Exceptions</h3>

Asynchronous exceptions are handled with exceptions listeners on the HlaWorld instance for each federate.
Examples of asynchronous exceptions:
<ul>
    <li>Failure to decode received data</li>
    <li>Failure to encode data to send</li>
    <li>Exceptions thrown in the user notification code</li>
    <li>Disconnected from federation</li>
    <li>Failure to perform save/restore and achieve synchronization point</li>
</ul>

The exception listener can be set with the following code:
<blockquote><pre>
class ExceptionListener : public HlaWorld::ExceptionListener {
public:
    void exceptionThrown(HlaExceptionPtr exception, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime) {
        // Handle exception...
    }
};
world->setExceptionListener(ExceptionListenerPtr(new ExceptionListener()));
</pre></blockquote>

The default exception listener will send the exception to the standard error stream (std::cerr).

<p>
<i>
Generated by Pitch Developer Studio version 6.2.0
<br>
Licensed to Roberto Cedeno, SEE, Project Edition
<br>
Generated 2024-02-15 21:12:24 (-0500) by ceden
<br>
Copyright (C) 2006-2023 Pitch Technologies AB. All rights reserved.
Use is subject to license terms.
</i>
</body>
</html>
