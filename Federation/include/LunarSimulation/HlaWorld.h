/*
 * DO NOT EDIT!
 * 
 * Automatically generated source code by Pitch Developer Studio
 * Licensed to Guidarly Joseph, SEE, Project Edition
 *
 * Copyright (C) 2006-2023 Pitch Technologies AB. All rights reserved.
 * Use is subject to license terms.
 */
#ifndef DEVELOPER_STUDIO_HLAWORLD_H
#define DEVELOPER_STUDIO_HLAWORLD_H

#ifdef _WIN32
#pragma warning( disable : 4290)
#endif

#include <vector>

#include <functional>

#include <LunarSimulation/HlaPointers.h>
#include <LunarSimulation/HlaException.h>
#include <LunarSimulation/HlaSettings.h>
#include <LunarSimulation/HlaLogicalTime.h>
#include <LunarSimulation/HlaTimeStampFactory.h>
#include <LunarSimulation/HlaWorldListener.h>
#include <LunarSimulation/HlaLibSettings.h>

namespace LunarSimulation {
    /**
    * Interface used get to all functions within a HLA Federation.
    * <p>
    * Generated by Pitch Developer Studio version 6.2.0
    * <br>
    * Licensed to Guidarly Joseph, SEE, Project Edition
    */
    class HlaWorld : private LunarSimulation::noncopyable {

    public:
        /**
        * Factory used to create an instance of the HlaWorld.
        */
        class Factory : private LunarSimulation::noncopyable {
        private:
            Factory();

        public:

            /**
            * Creates a HlaWorld with the specified settings and timestamps.
            *
            * The parameter <code>manualEvokeMode</code> decides if the instance will run in manual or auto evoke mode.
            *
            * <h3>Auto evoke mode</h3>
            * All notifications for this HlaWorld instance will be delivered in the same thread, a thread that is created
            * by HlaWorld. The notifications will be delivered automatically , as fast as possible. No need to call any
            * <code>evoke</code> methods.
            *
            * <h3>Manual evoke mode</h3>
            * In this mode notifications will be delivered when one of the evoke methods are called. The notification is
            * delivered in the same thread that makes the call to the notification method.
            * Note that the HlaWorld will be updated asynchronously, without need for <code>evoke</code>.
            *
            * If HlaSettings has been overridden with a <code>FederateConfig.txt</code> file in the current
            * directory, the supplied settings will <b>not</b> be used. A new settings object will be created using the
            * settings specified in the file.
            *
            * Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
            *
            * @param manualEvokeMode  if True, the created instance will be in manual evoke mode, otherwise auto.
            * @param settings         settings for this <code>HlaWorld</code>.
            * @param timeStampFactory factory used to create timestamps. The default factory is used if no timeStampFactory is supplied.
            *                         The timestamp factory can also be used to set the <code>HLA User Defined Tag</code>.
            *
            * @return the HlaWorld instance
            */
            LIBAPI static HlaWorldPtr create(
                bool manualEvokeMode = false,
                HlaSettingsPtr settings = HlaSettingsPtr(),
                HlaTimeStampFactoryPtr timeStampFactory = HlaTimeStampFactoryPtr()
            );
        };


        /**
        * An ExceptionListener is notified of internal exceptions.
        */
        class ExceptionListener {
        public:

            LIBAPI virtual ~ExceptionListener() {}

            /**
            * Function for determining if an exception is of a specific type.
            *
            * Example: bool result = instanceOf<HlaNotConnectedException>(exception);
            *
            * @param exception The exception
            */
            template <typename T1, typename T2> bool instanceOf(T2& exception) {
               return typeid(T1) == typeid(*exception);
            }

            /**
            * This method is called when an HlaException has been caught.
            *
            * @param exception  The exception that was caught.
            * @param timeStamp  The time when the exception was initiated.
            * @param logicalTime The logical time when the exception was initiated.
            */
            LIBAPI virtual void exceptionThrown(HlaExceptionPtr exception, HlaTimeStampPtr timeStamp, HlaLogicalTimePtr logicalTime) = 0;
        };

        typedef std::shared_ptr<ExceptionListener> ExceptionListenerPtr; /**< Pointer (shared_ptr) to the abstract class ExceptionListener. */

        /**
        * Connect to a federation. This will connect to the RTI, join and preform publish and subscribe HLA calls.
        * The name of the federation, the CRC location and other settings are defined in the settings supplied to
        * {@link Factory#create}
        *
        * @return the logical time for the current frame.
        *
        * @throws HlaConnectException            if failed to connect to the RTI
        * @throws HlaInvalidLicenseException     if the license is not valid
        * @throws HlaFomException                if the FOM is not correct
        * @throws HlaInvalidLogicalTimeException if step size or lookahead from HlaSettings is invalid
        * @throws HlaRtiException                if there are RTI related problems
        * @throws HlaInternalException           if there are internal problems
        * @throws HlaNotConnectedException       if the federate was disconnected during initialization
        * @throws HlaSaveInProgressException     if a federation save is in progress
        * @throws HlaRestoreInProgressException  if a federation restore is in progress
        * @throws HlaNormalizerException         if all Normalizers are not set
        */
        LIBAPI virtual HlaLogicalTimePtr connect()
        THROW_SPEC (HlaConnectException, HlaInvalidLicenseException, HlaFomException, HlaRtiException,
                    HlaInvalidLogicalTimeException, HlaInternalException, HlaNotConnectedException,
                    HlaSaveInProgressException, HlaRestoreInProgressException, HlaNormalizerException) = 0;

        /**
        * Disconnect from the federation.
        *
        * @throws HlaFederateOwnsAttributeException   if ownership acquisitions are pending or if attributes are owned
        *                                               and this not handled by the resign action
        * @throws HlaRtiException                     if there are RTI related problems
        * @throws HlaInternalException                if there are internal problems
        */
        LIBAPI virtual void disconnect() THROW_SPEC (HlaFederateOwnsAttributeException, HlaRtiException, HlaInternalException) = 0;

        /**
        * Advance the logical time to the next frame. This will perform the Time Advance Request HLA call.
        *
        * Note that this method does not support 0-lookahead, use <code>advanceToNextEvent()</code> instead.
        *
        * Note that this method is an implicit <code>evokeAll()</code> in manual evoke mode, to verify that all
        * notifications for the previous time has been processed before advancing to the next frame.
        *
        * @return the logical time for the new, now current, frame.
        *
        * @throws HlaNotConnectedException if not connected
        * @throws HlaRtiException if there are RTI related problems
        * @throws HlaInTimeAdvancingStateException If in advancing state
        * @throws HlaInternalException If there is an internal error
        * @throws HlaInvalidLogicalTimeException if the logical time is not valid.
        * @throws HlaSaveInProgressException if a federation save is in progress
        * @throws HlaRestoreInProgressException if a federation restore is in progress
        */
        LIBAPI virtual HlaLogicalTimePtr advanceToNextFrame()
        THROW_SPEC (HlaNotConnectedException, HlaRtiException, HlaInTimeAdvancingStateException,
                    HlaInvalidLogicalTimeException, HlaInternalException,
                    HlaSaveInProgressException, HlaRestoreInProgressException) = 0;

        /**
        * Enable time management. The federate will become regulating and/or constrained based on the settings objects supplied
        * on create. For this method to have any effect, the tuning flag ENABLE_TIME_MANAGEMENT_ON_CONNECT must be false.
        *
        * Note that this method will do nothing if constrained and regulating are false in settings.
        * Note that this method will do nothing if time management is already enabled, i.e. calling this multiple times has no effect.
        *
        * @return true if time management was enabled, otherwise false
        *
        * @throws HlaRtiException if there are RTI related problems
        * @throws HlaInternalException If there is an internal error
        * @throws HlaInvalidLogicalTimeException if the logical time is not valid.
        * @throws HlaNotConnectedException if the federate was disconnected during initialization
        */
        LIBAPI virtual bool enableTimeManagement()
        THROW_SPEC (HlaRtiException, HlaInternalException, HlaInvalidLogicalTimeException,
                    HlaInvalidLogicalTimeException) = 0;

        /**
        * Advance the logical time to the next event or, if no events are available, to the next frame.
        * This will perform the Next Message Request Available HLA call. This method support 0-lookahead so
        * that messages may be sent with the same logical time as the federate has advanced to.
        *
        * Note that this method is an implicit <code>evokeAll()</code> in manual evoke mode, to verify that all
        * notifications for the previous time has been processed before advancing to the next event.
        *
        * @return the logical time for the new, now current, frame.
        * @throws HlaNotConnectedException if not connected
        * @throws HlaRtiException if there are RTI related problems
        * @throws HlaInTimeAdvancingStateException If in advancing state
        * @throws HlaInternalException If there is an internal error
        * @throws HlaInvalidLogicalTimeException if the logical time is not valid.
        * @throws HlaSaveInProgressException if a federation save is in progress
        * @throws HlaRestoreInProgressException if a federation restore is in progress
        */
        LIBAPI virtual HlaLogicalTimePtr advanceToNextEvent()
        THROW_SPEC (HlaNotConnectedException, HlaRtiException, HlaInTimeAdvancingStateException,
                    HlaInvalidLogicalTimeException, HlaInternalException,
                    HlaSaveInProgressException, HlaRestoreInProgressException) = 0;

        /**
        * Advance to the specified logical time.
        * This will preform the Time Advance Request HLA call.
        *
        * Note that this method is an implicit <code>evokeAll()</code> in manual evoke mode, to verify that all
        * notifications for the previous time has been processed before advancing to the new time.
        *
        * @param logicalTime desired new logical time
        *
        * @return the logical time for the new, now current, frame.
        *
        * @throws HlaNotConnectedException if not connected
        * @throws HlaRtiException if there are RTI related problems
        * @throws HlaInTimeAdvancingStateException If in advancing state
        * @throws HlaInternalException If there is an internal error
        * @throws HlaInvalidLogicalTimeException if the logical time is not valid.
        * @throws HlaSaveInProgressException if a federation save is in progress
        * @throws HlaRestoreInProgressException if a federation restore is in progress
        */
        LIBAPI virtual HlaLogicalTimePtr advanceToLogicalTime(HlaLogicalTimePtr logicalTime)
        THROW_SPEC (HlaNotConnectedException, HlaRtiException, HlaInTimeAdvancingStateException,
                    HlaInvalidLogicalTimeException, HlaInternalException,
                    HlaSaveInProgressException, HlaRestoreInProgressException) = 0;

        /**
        * Invoke this function when in the granted state.
        * <p>
        * The function is invoked directly on this thread if the federate is in the granted state,
        * otherwise the function will be invoked when the federate is granted. Note that the federate
        * can not enter the advancing state until the function has completed.
        *
        * @param task to be invoked when granted
        */
        LIBAPI virtual void invokeWhenGranted(std::function<void()> task) = 0;

        /**
        * Get the logical time for the current frame.
        * This is the same as current logical time in the RTI.
        * Updated when a new time is granted by the RTI.
        *
        * @return the logical time for the current frame.
        */
        LIBAPI virtual HlaLogicalTimePtr getCurrentLogicalTime() = 0;

        /**
        * Get the logical time for the next frame.
        * Updated when a new time is granted by the RTI
        * to <code>granted time + step size</code>.
        *
        * @return the logical time for the next frame.
        */
        LIBAPI virtual HlaLogicalTimePtr getNextLogicalTime() = 0;

        /**
        * Get the next logical time that is valid to use for sending events.
        * This is usually same as <code>next logical time</code>.
        * Updated to <code>next logical time + look-ahead</code> when advancing,
        * and updated to <code>granted time + look-ahead</code> when granted.
        *
        * @return the next valid logical time that is valid to use for sending events.
        */
        LIBAPI virtual HlaLogicalTimePtr getDefaultSendTime() = 0;

        /**
        * Create a new logical time with the supplied value.
        *
        * @param value value to use
        *
        * @return the new logical time with the supplied value.
        */
        LIBAPI virtual HlaLogicalTimePtr createLogicalTime(long long value) = 0;

        /**
        * Create an invalid logical time.
        *
        * @return the invalid logical time.
        */
        LIBAPI virtual HlaLogicalTimePtr createInvalidLogicalTime() = 0;

        /**
        * Get the current time.
        *
        * @return the current time.
        */
        LIBAPI virtual HlaTimeStampPtr getCurrentTime() = 0;

        /**
        * Get the time stamp factory.
        *
        * @return the time stamp factory.
        */
        LIBAPI virtual HlaTimeStampFactoryPtr getTimeStampFactory() = 0;

        /**
        * Get Settings.
        *
        * @return settings.
        */
        LIBAPI virtual HlaSettingsPtr getSettings() = 0;

        /**
        * Get the encoded <code>HLA federate handle</code> for this federate.
        *
        * @return the encoded <code>HLA federate handle</code> for this federate, or an empty vector if not joined.
        */
        LIBAPI virtual std::vector<char> getEncodedHlaFederateHandle() = 0;

        /**
        * Get the FederateId for this federate.
        *
        * @return the FederateId for this federate
        */
        LIBAPI virtual HlaFederateIdPtr getFederateId() = 0;

        /**
        * Gives the number of pending notifications.
        *
        * @return the number of pending notifications.
        */
        LIBAPI virtual int peek() = 0;

        /**
        * Evokes a single notification from the notification queue. The notification will be called from this thread.
        * This method will return after the notification has returned. If there are no pending notifications,
        * this method will return immediately.
        *
        * If this HlaWorld is in auto evoke mode, this method will be a no op.
        *
        * Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
        */
        LIBAPI virtual void evoke() = 0;

        /**
        * Evokes all pending notifications from the notification queue. The notifications will be called from this
        * thread, one at a time. This method returns when the notification queue is empty.
        *
        * Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
        *
        * If this HlaWorld is in auto evoke mode, this method will be a no op.
        */
        LIBAPI virtual void evokeAll() = 0;

        /**
        * Evokes notifications for at least <code>millis</code> milliseconds with this thread.
        * If all pending notifications are processed before <code>millis</code> milliseconds have elapsed,
        * the current thread is suspended until either some more notifications arrive, or the time has elapsed.
        *
        * Note that this method could return even when there are pending notifications left.
        *
        * If this HlaWorld is in auto evoke mode, this will suspend the current thread until the time has elapsed.
        *
        * Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
        *
        * @param millis The minimum time, in ms, to process notifications.
        */
        LIBAPI virtual void evokeAll(unsigned long long millis) = 0;

        /**
        * Disable automatic invocations of notifications. No <b>new</b> notifications will be invoked after
        * <code>disableNotifications()</code> has <b>returned</b>.
        *
        * Note that notifications has to be manually enabled once disabled.
        *
        * If this HlaWorld is in manual evoke mode, this method will be a no op.
        */
        LIBAPI virtual void disableNotifications() = 0;

        /**
        * Enable automatic invocations of notifications.
        *
        * Note that the HlaWorld is started in the enabled state, so notifications has to be disabled first before
        * this function has any effect.
        *
        * If this HlaWorld is in manual evoke mode, this method will be a no op.
        */
        LIBAPI virtual void enableNotifications() = 0;

        /**
        * Get the HlaHLAobjectRoot manager.
        *
        * @return the HlaHLAobjectRoot manager
        */
        LIBAPI virtual HlaHLAobjectRootManagerPtr getHlaHLAobjectRootManager() = 0;

        /**
        * Get the HlaPhysicalEntity manager.
        *
        * @return the HlaPhysicalEntity manager
        */
        LIBAPI virtual HlaPhysicalEntityManagerPtr getHlaPhysicalEntityManager() = 0;

        /**
        * Get the HlaDynamicalEntity manager.
        *
        * @return the HlaDynamicalEntity manager
        */
        LIBAPI virtual HlaDynamicalEntityManagerPtr getHlaDynamicalEntityManager() = 0;

        /**
        * Get the HlaPayload manager.
        *
        * @return the HlaPayload manager
        */
        LIBAPI virtual HlaPayloadManagerPtr getHlaPayloadManager() = 0;

        /**
        * Get the HlaLauncher manager.
        *
        * @return the HlaLauncher manager
        */
        LIBAPI virtual HlaLauncherManagerPtr getHlaLauncherManager() = 0;

        /**
        * Get the HlaPhysicalInterface manager.
        *
        * @return the HlaPhysicalInterface manager
        */
        LIBAPI virtual HlaPhysicalInterfaceManagerPtr getHlaPhysicalInterfaceManager() = 0;

        /**
        * Get the HlaReferenceFrame manager.
        *
        * @return the HlaReferenceFrame manager
        */
        LIBAPI virtual HlaReferenceFrameManagerPtr getHlaReferenceFrameManager() = 0;

        /**
        * Get the HlaMoon manager.
        *
        * @return the HlaMoon manager
        */
        LIBAPI virtual HlaMoonManagerPtr getHlaMoonManager() = 0;

        /**
        * Get the HlaExecutionConfiguration manager.
        *
        * @return the HlaExecutionConfiguration manager
        */
        LIBAPI virtual HlaExecutionConfigurationManagerPtr getHlaExecutionConfigurationManager() = 0;

        /**
        * Get the interaction manager.
        *
        * @return the interaction manager
        */
        LIBAPI virtual HlaInteractionManagerPtr getHlaInteractionManager() = 0;

        /**
        * Get the save and restore manager.
        *
        * @return the save and restore manager
        */
        LIBAPI virtual HlaSaveRestoreManagerPtr getHlaSaveRestoreManager() = 0;

        /**
        * Get the synchronization manager.
        *
        * @return the synchronization manager
        */
        LIBAPI virtual HlaSynchronizationManagerPtr getHlaSynchronizationManager() = 0;

        /**
        * Sets the exception handler for this HlaWorld to <code>exceptionListener</code>.
        * The exception handler is notified when this HlaWorld catches exceptions.
        *
        * @param exceptionListener   The exception handler for this HlaWorld,
        *                            if <code>null</code> the default exception listener will be used.
        */
        LIBAPI virtual void setExceptionListener(HlaWorld::ExceptionListenerPtr exceptionListener) = 0;

        LIBAPI virtual ~HlaWorld() {}

       /**
        * Add a HlaWorldListener.
        *
        * @param listener HlaWorldListener to add
        */
        LIBAPI virtual void addHlaWorldListener(HlaWorldListenerPtr listener) = 0;

       /**
        * Remove a HlaWorldListener.
        *
        * @param listener HlaWorldListener to remove
        */
        LIBAPI virtual void removeHlaWorldListener(HlaWorldListenerPtr listener) = 0;
    };
}
#endif
