<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--
   DO NOT EDIT!

   Automatically generated by Pitch Developer Studio
   Licensed to Guidarly Joseph, SEE, Project Edition

   Copyright (C) 2006-2023 Pitch Technologies AB. All rights reserved.
   Use is subject to license terms.
-->
<html>

<head>
    <title>Overview Documentation</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >

<script type="application/javascript">

    function createTOCEntry(node) {
        var li = document.createElement("li");
        var a = document.createElement("a");
        a.setAttribute("href","#" + node.id);
        a.innerHTML = node.innerHTML;
        li.appendChild(a);
        return li;
    }

    function prependSectionNumber(node,sectionNumber) {
        node.insertBefore(document.createTextNode(sectionNumber + ". "), node.firstChild);
        node.id = "section" + sectionNumber;
    }

    function generateTOC(toc) {
        var h2level = 0;
        var h3level = 0;
        toc = toc.appendChild(document.createElement("ul"));
        for (var i = 0; i < document.body.childNodes.length; i++) {
            var node = document.body.childNodes[i];
            var tagName = node.nodeName.toLowerCase();
            var sectionNumber = "";
            if (tagName == "h2") {
                ++h2level;
                h3level = 0;
                prependSectionNumber(node,h2level);
                toc.appendChild(createTOCEntry(node));
            } else if (tagName == "h3") {
                ++h3level;

                //Create new level
                if (h3level == 1) {
                    toc.lastChild.appendChild(document.createElement("ul"));
                }
                prependSectionNumber(node,h2level + "." + h3level);
                toc.lastChild.lastChild.appendChild(createTOCEntry(node));
            }
        }
    }

</script>

<style type="text/css">

h3, h4 {
    color: #555;
}

table {
    margin-left: 30px;
    border-collapse: collapse;
    border-spacing: 0;
    border: 1px #fff solid;
}

thead {
    background-color: #666;
    color: #fff;
}

th {
    font-weight: bold;
    padding-left: 10px;
    padding-right: 10px;
}

tbody {
    background-color: #ddd;
    color: #000;
    border: 1px #fff solid;
}

td {
    font-style: normal;
    padding-left: 10px;
    padding-right: 10px;
    border: 1px #fff solid;
}

blockquote {
    margin-left: 30px;
    border: 1px dashed;
    padding-left: 10px;
    background-color: #ddd;
    overflow: auto;
}

div#toc ul {
    list-style-type: none;
}

a {
    text-decoration: none;
}

/* Fix for to much padding of <pre> inside <table> */
table pre {
    margin: 0;
}

</style>
</head>

<body onload="generateTOC(document.getElementById('toc'));">


<h1>Overview Documentation</h1>

<h2>General</h2>
<p>You have successfully generated code for your application. This document provides an overview of generated code.
A full set of documentation of all generated code is also available in the generated Javadoc
(<a href="javadoc/index.html">link</a>)

<h3>Table of Contents</h3>
<div id="toc"></div>

<h2>Getting Connected to an HLA Federation</h2>

To connect to an HLA federation you need an instance of the object <code>HlaWorld</code>. An <code>HlaWorld</code>
instance can be created by the <code>HlaWorld.Factory</code> class. When creating an <code>HlaWorld</code> you can
either use the default settings that was defined when the code was generated or supply your own implementation of the
<code>HlaSettings</code> interface.
<p>

When you have created a <code>HlaWorld</code> you can call the <code>connect</code> method which connects to the
federation. When you wish to leave the federation you should simply call the <code>disconnect</code> method.
<p>

This is what the Java code may look like:

<blockquote><pre>
HlaWorld hlaWorld = HlaWorld.Factory.create();
hlaWorld.connect();
// simulate...
hlaWorld.disconnect();
</pre></blockquote>

If you are going to connect to several HLA federations you need to create one <code>HlaWorld</code>
instance for each federation. Note that you should not modify the generated code for <code>HlaWorld</code>
and <code>HlaSettings</code>. Read more in the <code>HlaWorld</code> Javadoc
(<a href="javadoc/core/HlaWorld.html">link</a>).

It's possible to add a world listener to <code>HlaWorld</code> that will be notified when <code>HlaWorld</code>
is connected or disconnected. For example:

<blockquote><pre>
private class WorldListener extends HlaWorldListener.Adapter {
    public void connected(HlaTimeStamp timeStamp) {
        System.out.println("Connected");
    }

    public void disconnected(HlaTimeStamp timeStamp) {
        System.out.println("Disconnected");
    }
}
hlaWorld.addHlaWorldListener(new WorldListener());
</pre></blockquote>


<h3>Object Classes</h3>

For each object class in the federation that you will support, a number of classes have been
generated. You have chosen to support the following classes:

<ol>
    <li>HlaHLAobjectRoot (<a href="javadoc/core/HlaHLAobjectRoot.html">link</a>)</li>
    <li>HlaPhysicalEntity (<a href="javadoc/core/HlaPhysicalEntity.html">link</a>)</li>
    <li>HlaDynamicalEntity (<a href="javadoc/core/HlaDynamicalEntity.html">link</a>)</li>
    <li>HlaPayload (<a href="javadoc/core/HlaPayload.html">link</a>)</li>
    <li>HlaLauncher (<a href="javadoc/core/HlaLauncher.html">link</a>)</li>
    <li>HlaPhysicalInterface (<a href="javadoc/core/HlaPhysicalInterface.html">link</a>)</li>
    <li>HlaReferenceFrame (<a href="javadoc/core/HlaReferenceFrame.html">link</a>)</li>
    <li>HlaMoon (<a href="javadoc/core/HlaMoon.html">link</a>)</li>
    <li>HlaExecutionConfiguration (<a href="javadoc/core/HlaExecutionConfiguration.html">link</a>)</li>
</ol>


<h2>Handling Interactions</h2>

If you have chosen to direct some interaction to a particular object class, please read more
about these in the corresponding object class descriptions (below).

<h3>Receiving Global Interaction</h3>

To receive global interactions you need to implement the <code>HlaInteractionListener</code> interface, or
create a subclass of the <code>HlaInteractionListener.Adapter</code>, and attach it as a listener to
<code>HlaInteractionManager</code> using the <code>addHlaInteractionListener</code> method. You should then implement
the handling methods that you need from the <code>HlaInteractionListener</code> in your implementation. If
you for example have a globally handled interaction called <code>loadScenario</code>
you need to provide the following code.

<blockquote><pre>
HlaInteractionListener myInteractionListener = new HlaInteractionListener.Adapter() {
   public void loadScenario(boolean local,
                            HlaInteractionManager.HlaLoadScenarioParameters parameters,
                            HlaTimeStamp timeStamp, HlaLogicalTime logicalTime) {
      // Add implementation to handle interaction
   }
};
hlaWorld.getHlaInteractionManager().addHlaInteractionListener(myInteractionListener);
</pre></blockquote>

The following global interactions are supported as calls to your interaction listener:

<blockquote><pre>
hLAinteractionRoot(boolean local, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
startStop(boolean local, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
modeTransitionRequest(boolean local, HlaInteractionManager.HlaModeTransitionRequestParameters parameters, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

<h3>Sending Global Interactions</h3>

To send a global interaction you need to use the <code>HlaInteractionManager</code> to obtain an interaction
object, set the desired parameter values and finally call the <code>sendInteraction</code> method. If you for example have a
globally handled interaction called <code>loadScenario</code>, with two parameters called name and data, you can send that interaction as follows:

<blockquote><pre>
HlaInteractionManager.HlaLoadScenarioInteraction loadScenario = hlaWorld.getHlaInteractionManager().getHlaLoadScenarioInteraction();
loadScenario.setName("Alpha");
loadScenario.setData(135);
loadScenario.sendInteraction();
</pre></blockquote>

The following global interactions are available in your interaction manager:

<blockquote><pre>
HlaInteractionManager.HlaHLAinteractionRootInteraction hLAinteractionRoot = hlaWorld.getHlaInteractionManager().getHlaHLAinteractionRootInteraction();
HlaInteractionManager.HlaStartStopInteraction startStop = hlaWorld.getHlaInteractionManager().getHlaStartStopInteraction();
HlaInteractionManager.HlaModeTransitionRequestInteraction modeTransitionRequest = hlaWorld.getHlaInteractionManager().getHlaModeTransitionRequestInteraction();
</pre></blockquote>

Note that you should not modify the generated code. Read more about the
<code>HlaInteractionManager</code> and <code>HlaInteractionListener</code> in the Javadoc
(<a href="javadoc/core/HlaInteractionListener.html">link</a>).


<h2>Working with Object Classes</h2>

For each object class in the FOM that you have chosen to support, several Java classes have
been generated.
<p>

Each object class has a <code>Manager</code> that keeps track of all local and remote instances. A listener
can be attached to the manager to get notification when instances are discovered, initialized and
deleted. The manager is also used to create new local instances.
<p>

Each object class has several supporting interfaces:
<ul>
    <li>An interface with all the <code>Attribute</code>s defined. Getters exists to be able to get an instances attribute values.
    </li>
    <li>An <code>Updater</code> that is used when changing attribute values for a local instance</li>
    <li>Two <code>Listener</code>s for when the attribute values of an instance is updated, one contains the
        set of updated attributes without values and the other contains each updated attribute
        with the new value.
    </li>
</ul>

How to attach a listener to an object instance, Aircraft example:
<blockquote><pre>
class MyAircraftValueListener extends HlaAircraftValueListener.Adapter {
        public void positionUpdated(HlaAircraft aircraft, PositionRec position, boolean validOldPosition, PositionRec oldPosition, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime) {
            // Do something when Aircraft position is updated.
        }
    }

    class MyAircraftManagerListener extends HlaAircraftManagerListener.Adapter {
        public void hlaAircraftDiscovered(HlaAircraft aircraft, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime) {
            aircraft.addHlaAircraftValueListener(new MyAircraftValueListener());
        }
    }
</pre></blockquote>

All the classes and interfaces are described in more detail below.



<h3>HLAobjectRoot Class</h3>


<h4>Working with HLAobjectRoot Instances</h4>

To work with HLAobjectRoot you first need to get the <code>HlaHLAobjectRootManager</code> instance which is
available through the <code>HlaWorld.getHlaHLAobjectRootManager</code> method.
<p>

To work with object instances you may use the <code>HlaHLAobjectRootManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaHLAobjectRootManager.getHlaHLAobjectRoots()
HlaHLAobjectRootManager.getLocalHlaHLAobjectRoots()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaHLAobjectRootManager.getHLAobjectRootByHlaInstanceName(String instanceName)
HlaHLAobjectRootManager.getHLAobjectRootByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each HLAobjectRoot attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaHLAobjectRoot.getHlaHLAobjectRootAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaHLAobjectRootValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
</pre></blockquote>

You may also implement the <code>HlaHLAobjectRootValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaHLAobjectRootListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaHLAobjectRootListener.attributesUpdated(HlaHLAobjectRoot hLAobjectRoot, Set&lt;HlaHLAobjectRootAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of HLAobjectRoot:

<blockquote><pre>
HlaHLAobjectRootManager.createLocalHlaHLAobjectRoot(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaHLAobjectRootManager.createLocalHlaHLAobjectRoot(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaHLAobjectRootUpdater</code> as follows:

<blockquote><pre>
HlaHLAobjectRootUpdater updater = myInstance.getHlaHLAobjectRootUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>PhysicalEntity Class</h3>


<h4>Working with PhysicalEntity Instances</h4>

To work with PhysicalEntity you first need to get the <code>HlaPhysicalEntityManager</code> instance which is
available through the <code>HlaWorld.getHlaPhysicalEntityManager</code> method.
<p>

To work with object instances you may use the <code>HlaPhysicalEntityManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaPhysicalEntityManager.getHlaPhysicalEntitys()
HlaPhysicalEntityManager.getLocalHlaPhysicalEntitys()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaPhysicalEntityManager.getPhysicalEntityByHlaInstanceName(String instanceName)
HlaPhysicalEntityManager.getPhysicalEntityByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each PhysicalEntity attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
boolean hasName();
String getName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getNameTimeStamped() throws HlaValueNotSetException;

boolean hasType();
String getType() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getTypeTimeStamped() throws HlaValueNotSetException;

boolean hasStatus();
String getStatus() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getStatusTimeStamped() throws HlaValueNotSetException;

boolean hasParentReferenceFrame();
String getParentReferenceFrame() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getParentReferenceFrameTimeStamped() throws HlaValueNotSetException;

boolean hasState();
SpaceTimeCoordinateState getState() throws HlaValueNotSetException;
HlaTimeStamped&lt;SpaceTimeCoordinateState> getStateTimeStamped() throws HlaValueNotSetException;

boolean hasAcceleration();
double[/* 3 */] getAcceleration() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getAccelerationTimeStamped() throws HlaValueNotSetException;

boolean hasRotationalAcceleration();
double[/* 3 */] getRotationalAcceleration() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getRotationalAccelerationTimeStamped() throws HlaValueNotSetException;

boolean hasCenterOfMass();
double[/* 3 */] getCenterOfMass() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getCenterOfMassTimeStamped() throws HlaValueNotSetException;

boolean hasBodyWrtStructural();
AttitudeQuaternion getBodyWrtStructural() throws HlaValueNotSetException;
HlaTimeStamped&lt;AttitudeQuaternion> getBodyWrtStructuralTimeStamped() throws HlaValueNotSetException;

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaPhysicalEntity.getHlaPhysicalEntityAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaPhysicalEntityValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaPhysicalEntityValueListener.nameUpdated(HlaPhysicalEntity physicalEntity, String name, boolean validOldName, String oldName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalEntityValueListener.typeUpdated(HlaPhysicalEntity physicalEntity, String type, boolean validOldType, String oldType, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalEntityValueListener.statusUpdated(HlaPhysicalEntity physicalEntity, String status, boolean validOldStatus, String oldStatus, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalEntityValueListener.parentReferenceFrameUpdated(HlaPhysicalEntity physicalEntity, String parentReferenceFrame, boolean validOldParentReferenceFrame, String oldParentReferenceFrame, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalEntityValueListener.stateUpdated(HlaPhysicalEntity physicalEntity, SpaceTimeCoordinateState state, boolean validOldState, SpaceTimeCoordinateState oldState, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalEntityValueListener.accelerationUpdated(HlaPhysicalEntity physicalEntity, double[/* 3 */] acceleration, boolean validOldAcceleration, double[/* 3 */] oldAcceleration, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalEntityValueListener.rotationalAccelerationUpdated(HlaPhysicalEntity physicalEntity, double[/* 3 */] rotationalAcceleration, boolean validOldRotationalAcceleration, double[/* 3 */] oldRotationalAcceleration, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalEntityValueListener.centerOfMassUpdated(HlaPhysicalEntity physicalEntity, double[/* 3 */] centerOfMass, boolean validOldCenterOfMass, double[/* 3 */] oldCenterOfMass, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalEntityValueListener.bodyWrtStructuralUpdated(HlaPhysicalEntity physicalEntity, AttitudeQuaternion bodyWrtStructural, boolean validOldBodyWrtStructural, AttitudeQuaternion oldBodyWrtStructural, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

You may also implement the <code>HlaPhysicalEntityValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaPhysicalEntityListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaPhysicalEntityListener.attributesUpdated(HlaPhysicalEntity physicalEntity, Set&lt;HlaPhysicalEntityAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of PhysicalEntity:

<blockquote><pre>
HlaPhysicalEntityManager.createLocalHlaPhysicalEntity(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaPhysicalEntityManager.createLocalHlaPhysicalEntity(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaPhysicalEntityUpdater</code> as follows:

<blockquote><pre>
HlaPhysicalEntityUpdater updater = myInstance.getHlaPhysicalEntityUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>DynamicalEntity Class</h3>


<h4>Working with DynamicalEntity Instances</h4>

To work with DynamicalEntity you first need to get the <code>HlaDynamicalEntityManager</code> instance which is
available through the <code>HlaWorld.getHlaDynamicalEntityManager</code> method.
<p>

To work with object instances you may use the <code>HlaDynamicalEntityManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaDynamicalEntityManager.getHlaDynamicalEntitys()
HlaDynamicalEntityManager.getLocalHlaDynamicalEntitys()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaDynamicalEntityManager.getDynamicalEntityByHlaInstanceName(String instanceName)
HlaDynamicalEntityManager.getDynamicalEntityByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each DynamicalEntity attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
boolean hasForce();
double[/* 3 */] getForce() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getForceTimeStamped() throws HlaValueNotSetException;

boolean hasTorque();
double[/* 3 */] getTorque() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getTorqueTimeStamped() throws HlaValueNotSetException;

boolean hasMass();
double getMass() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getMassTimeStamped() throws HlaValueNotSetException;

boolean hasMassRate();
double getMassRate() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getMassRateTimeStamped() throws HlaValueNotSetException;

boolean hasInertia();
double[/* 9 */] getInertia() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 9 */]> getInertiaTimeStamped() throws HlaValueNotSetException;

boolean hasInertiaRate();
double[/* 9 */] getInertiaRate() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 9 */]> getInertiaRateTimeStamped() throws HlaValueNotSetException;

boolean hasName();
String getName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getNameTimeStamped() throws HlaValueNotSetException;

boolean hasType();
String getType() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getTypeTimeStamped() throws HlaValueNotSetException;

boolean hasStatus();
String getStatus() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getStatusTimeStamped() throws HlaValueNotSetException;

boolean hasParentReferenceFrame();
String getParentReferenceFrame() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getParentReferenceFrameTimeStamped() throws HlaValueNotSetException;

boolean hasState();
SpaceTimeCoordinateState getState() throws HlaValueNotSetException;
HlaTimeStamped&lt;SpaceTimeCoordinateState> getStateTimeStamped() throws HlaValueNotSetException;

boolean hasAcceleration();
double[/* 3 */] getAcceleration() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getAccelerationTimeStamped() throws HlaValueNotSetException;

boolean hasRotationalAcceleration();
double[/* 3 */] getRotationalAcceleration() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getRotationalAccelerationTimeStamped() throws HlaValueNotSetException;

boolean hasCenterOfMass();
double[/* 3 */] getCenterOfMass() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getCenterOfMassTimeStamped() throws HlaValueNotSetException;

boolean hasBodyWrtStructural();
AttitudeQuaternion getBodyWrtStructural() throws HlaValueNotSetException;
HlaTimeStamped&lt;AttitudeQuaternion> getBodyWrtStructuralTimeStamped() throws HlaValueNotSetException;

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaDynamicalEntity.getHlaDynamicalEntityAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaDynamicalEntityValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaDynamicalEntityValueListener.forceUpdated(HlaDynamicalEntity dynamicalEntity, double[/* 3 */] force, boolean validOldForce, double[/* 3 */] oldForce, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.torqueUpdated(HlaDynamicalEntity dynamicalEntity, double[/* 3 */] torque, boolean validOldTorque, double[/* 3 */] oldTorque, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.massUpdated(HlaDynamicalEntity dynamicalEntity, double mass, boolean validOldMass, double oldMass, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.massRateUpdated(HlaDynamicalEntity dynamicalEntity, double massRate, boolean validOldMassRate, double oldMassRate, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.inertiaUpdated(HlaDynamicalEntity dynamicalEntity, double[/* 9 */] inertia, boolean validOldInertia, double[/* 9 */] oldInertia, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.inertiaRateUpdated(HlaDynamicalEntity dynamicalEntity, double[/* 9 */] inertiaRate, boolean validOldInertiaRate, double[/* 9 */] oldInertiaRate, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.nameUpdated(HlaDynamicalEntity dynamicalEntity, String name, boolean validOldName, String oldName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.typeUpdated(HlaDynamicalEntity dynamicalEntity, String type, boolean validOldType, String oldType, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.statusUpdated(HlaDynamicalEntity dynamicalEntity, String status, boolean validOldStatus, String oldStatus, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.parentReferenceFrameUpdated(HlaDynamicalEntity dynamicalEntity, String parentReferenceFrame, boolean validOldParentReferenceFrame, String oldParentReferenceFrame, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.stateUpdated(HlaDynamicalEntity dynamicalEntity, SpaceTimeCoordinateState state, boolean validOldState, SpaceTimeCoordinateState oldState, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.accelerationUpdated(HlaDynamicalEntity dynamicalEntity, double[/* 3 */] acceleration, boolean validOldAcceleration, double[/* 3 */] oldAcceleration, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.rotationalAccelerationUpdated(HlaDynamicalEntity dynamicalEntity, double[/* 3 */] rotationalAcceleration, boolean validOldRotationalAcceleration, double[/* 3 */] oldRotationalAcceleration, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.centerOfMassUpdated(HlaDynamicalEntity dynamicalEntity, double[/* 3 */] centerOfMass, boolean validOldCenterOfMass, double[/* 3 */] oldCenterOfMass, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaDynamicalEntityValueListener.bodyWrtStructuralUpdated(HlaDynamicalEntity dynamicalEntity, AttitudeQuaternion bodyWrtStructural, boolean validOldBodyWrtStructural, AttitudeQuaternion oldBodyWrtStructural, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

You may also implement the <code>HlaDynamicalEntityValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaDynamicalEntityListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaDynamicalEntityListener.attributesUpdated(HlaDynamicalEntity dynamicalEntity, Set&lt;HlaDynamicalEntityAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of DynamicalEntity:

<blockquote><pre>
HlaDynamicalEntityManager.createLocalHlaDynamicalEntity(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaDynamicalEntityManager.createLocalHlaDynamicalEntity(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaDynamicalEntityUpdater</code> as follows:

<blockquote><pre>
HlaDynamicalEntityUpdater updater = myInstance.getHlaDynamicalEntityUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>Payload Class</h3>


<h4>Working with Payload Instances</h4>

To work with Payload you first need to get the <code>HlaPayloadManager</code> instance which is
available through the <code>HlaWorld.getHlaPayloadManager</code> method.
<p>

To work with object instances you may use the <code>HlaPayloadManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaPayloadManager.getHlaPayloads()
HlaPayloadManager.getLocalHlaPayloads()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaPayloadManager.getPayloadByHlaInstanceName(String instanceName)
HlaPayloadManager.getPayloadByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each Payload attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
boolean hasPosition();
double[/* 3 */] getPosition() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getPositionTimeStamped() throws HlaValueNotSetException;

boolean hasVelocity();
double[/* 3 */] getVelocity() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getVelocityTimeStamped() throws HlaValueNotSetException;

boolean hasHealth();
double getHealth() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getHealthTimeStamped() throws HlaValueNotSetException;

boolean hasForce();
double[/* 3 */] getForce() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getForceTimeStamped() throws HlaValueNotSetException;

boolean hasTorque();
double[/* 3 */] getTorque() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getTorqueTimeStamped() throws HlaValueNotSetException;

boolean hasMass();
double getMass() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getMassTimeStamped() throws HlaValueNotSetException;

boolean hasMassRate();
double getMassRate() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getMassRateTimeStamped() throws HlaValueNotSetException;

boolean hasInertia();
double[/* 9 */] getInertia() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 9 */]> getInertiaTimeStamped() throws HlaValueNotSetException;

boolean hasInertiaRate();
double[/* 9 */] getInertiaRate() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 9 */]> getInertiaRateTimeStamped() throws HlaValueNotSetException;

boolean hasName();
String getName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getNameTimeStamped() throws HlaValueNotSetException;

boolean hasType();
String getType() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getTypeTimeStamped() throws HlaValueNotSetException;

boolean hasStatus();
String getStatus() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getStatusTimeStamped() throws HlaValueNotSetException;

boolean hasParentReferenceFrame();
String getParentReferenceFrame() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getParentReferenceFrameTimeStamped() throws HlaValueNotSetException;

boolean hasState();
SpaceTimeCoordinateState getState() throws HlaValueNotSetException;
HlaTimeStamped&lt;SpaceTimeCoordinateState> getStateTimeStamped() throws HlaValueNotSetException;

boolean hasAcceleration();
double[/* 3 */] getAcceleration() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getAccelerationTimeStamped() throws HlaValueNotSetException;

boolean hasRotationalAcceleration();
double[/* 3 */] getRotationalAcceleration() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getRotationalAccelerationTimeStamped() throws HlaValueNotSetException;

boolean hasCenterOfMass();
double[/* 3 */] getCenterOfMass() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getCenterOfMassTimeStamped() throws HlaValueNotSetException;

boolean hasBodyWrtStructural();
AttitudeQuaternion getBodyWrtStructural() throws HlaValueNotSetException;
HlaTimeStamped&lt;AttitudeQuaternion> getBodyWrtStructuralTimeStamped() throws HlaValueNotSetException;

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaPayload.getHlaPayloadAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaPayloadValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaPayloadValueListener.positionUpdated(HlaPayload payload, double[/* 3 */] position, boolean validOldPosition, double[/* 3 */] oldPosition, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.velocityUpdated(HlaPayload payload, double[/* 3 */] velocity, boolean validOldVelocity, double[/* 3 */] oldVelocity, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.healthUpdated(HlaPayload payload, double health, boolean validOldHealth, double oldHealth, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.forceUpdated(HlaPayload payload, double[/* 3 */] force, boolean validOldForce, double[/* 3 */] oldForce, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.torqueUpdated(HlaPayload payload, double[/* 3 */] torque, boolean validOldTorque, double[/* 3 */] oldTorque, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.massUpdated(HlaPayload payload, double mass, boolean validOldMass, double oldMass, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.massRateUpdated(HlaPayload payload, double massRate, boolean validOldMassRate, double oldMassRate, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.inertiaUpdated(HlaPayload payload, double[/* 9 */] inertia, boolean validOldInertia, double[/* 9 */] oldInertia, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.inertiaRateUpdated(HlaPayload payload, double[/* 9 */] inertiaRate, boolean validOldInertiaRate, double[/* 9 */] oldInertiaRate, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.nameUpdated(HlaPayload payload, String name, boolean validOldName, String oldName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.typeUpdated(HlaPayload payload, String type, boolean validOldType, String oldType, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.statusUpdated(HlaPayload payload, String status, boolean validOldStatus, String oldStatus, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.parentReferenceFrameUpdated(HlaPayload payload, String parentReferenceFrame, boolean validOldParentReferenceFrame, String oldParentReferenceFrame, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.stateUpdated(HlaPayload payload, SpaceTimeCoordinateState state, boolean validOldState, SpaceTimeCoordinateState oldState, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.accelerationUpdated(HlaPayload payload, double[/* 3 */] acceleration, boolean validOldAcceleration, double[/* 3 */] oldAcceleration, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.rotationalAccelerationUpdated(HlaPayload payload, double[/* 3 */] rotationalAcceleration, boolean validOldRotationalAcceleration, double[/* 3 */] oldRotationalAcceleration, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.centerOfMassUpdated(HlaPayload payload, double[/* 3 */] centerOfMass, boolean validOldCenterOfMass, double[/* 3 */] oldCenterOfMass, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPayloadValueListener.bodyWrtStructuralUpdated(HlaPayload payload, AttitudeQuaternion bodyWrtStructural, boolean validOldBodyWrtStructural, AttitudeQuaternion oldBodyWrtStructural, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

You may also implement the <code>HlaPayloadValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaPayloadListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaPayloadListener.attributesUpdated(HlaPayload payload, Set&lt;HlaPayloadAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of Payload:

<blockquote><pre>
HlaPayloadManager.createLocalHlaPayload(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaPayloadManager.createLocalHlaPayload(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaPayloadUpdater</code> as follows:

<blockquote><pre>
HlaPayloadUpdater updater = myInstance.getHlaPayloadUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>Launcher Class</h3>


<h4>Working with Launcher Instances</h4>

To work with Launcher you first need to get the <code>HlaLauncherManager</code> instance which is
available through the <code>HlaWorld.getHlaLauncherManager</code> method.
<p>

To work with object instances you may use the <code>HlaLauncherManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaLauncherManager.getHlaLaunchers()
HlaLauncherManager.getLocalHlaLaunchers()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaLauncherManager.getLauncherByHlaInstanceName(String instanceName)
HlaLauncherManager.getLauncherByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each Launcher attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
boolean hasPosition();
double[/* 3 */] getPosition() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getPositionTimeStamped() throws HlaValueNotSetException;

boolean hasMass();
double getMass() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getMassTimeStamped() throws HlaValueNotSetException;

boolean hasEnergy();
double getEnergy() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getEnergyTimeStamped() throws HlaValueNotSetException;

boolean hasName();
String getName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getNameTimeStamped() throws HlaValueNotSetException;

boolean hasType();
String getType() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getTypeTimeStamped() throws HlaValueNotSetException;

boolean hasStatus();
String getStatus() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getStatusTimeStamped() throws HlaValueNotSetException;

boolean hasParentReferenceFrame();
String getParentReferenceFrame() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getParentReferenceFrameTimeStamped() throws HlaValueNotSetException;

boolean hasState();
SpaceTimeCoordinateState getState() throws HlaValueNotSetException;
HlaTimeStamped&lt;SpaceTimeCoordinateState> getStateTimeStamped() throws HlaValueNotSetException;

boolean hasAcceleration();
double[/* 3 */] getAcceleration() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getAccelerationTimeStamped() throws HlaValueNotSetException;

boolean hasRotationalAcceleration();
double[/* 3 */] getRotationalAcceleration() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getRotationalAccelerationTimeStamped() throws HlaValueNotSetException;

boolean hasCenterOfMass();
double[/* 3 */] getCenterOfMass() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getCenterOfMassTimeStamped() throws HlaValueNotSetException;

boolean hasBodyWrtStructural();
AttitudeQuaternion getBodyWrtStructural() throws HlaValueNotSetException;
HlaTimeStamped&lt;AttitudeQuaternion> getBodyWrtStructuralTimeStamped() throws HlaValueNotSetException;

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaLauncher.getHlaLauncherAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaLauncherValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaLauncherValueListener.positionUpdated(HlaLauncher launcher, double[/* 3 */] position, boolean validOldPosition, double[/* 3 */] oldPosition, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.massUpdated(HlaLauncher launcher, double mass, boolean validOldMass, double oldMass, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.energyUpdated(HlaLauncher launcher, double energy, boolean validOldEnergy, double oldEnergy, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.nameUpdated(HlaLauncher launcher, String name, boolean validOldName, String oldName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.typeUpdated(HlaLauncher launcher, String type, boolean validOldType, String oldType, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.statusUpdated(HlaLauncher launcher, String status, boolean validOldStatus, String oldStatus, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.parentReferenceFrameUpdated(HlaLauncher launcher, String parentReferenceFrame, boolean validOldParentReferenceFrame, String oldParentReferenceFrame, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.stateUpdated(HlaLauncher launcher, SpaceTimeCoordinateState state, boolean validOldState, SpaceTimeCoordinateState oldState, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.accelerationUpdated(HlaLauncher launcher, double[/* 3 */] acceleration, boolean validOldAcceleration, double[/* 3 */] oldAcceleration, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.rotationalAccelerationUpdated(HlaLauncher launcher, double[/* 3 */] rotationalAcceleration, boolean validOldRotationalAcceleration, double[/* 3 */] oldRotationalAcceleration, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.centerOfMassUpdated(HlaLauncher launcher, double[/* 3 */] centerOfMass, boolean validOldCenterOfMass, double[/* 3 */] oldCenterOfMass, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaLauncherValueListener.bodyWrtStructuralUpdated(HlaLauncher launcher, AttitudeQuaternion bodyWrtStructural, boolean validOldBodyWrtStructural, AttitudeQuaternion oldBodyWrtStructural, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

You may also implement the <code>HlaLauncherValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaLauncherListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaLauncherListener.attributesUpdated(HlaLauncher launcher, Set&lt;HlaLauncherAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of Launcher:

<blockquote><pre>
HlaLauncherManager.createLocalHlaLauncher(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaLauncherManager.createLocalHlaLauncher(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaLauncherUpdater</code> as follows:

<blockquote><pre>
HlaLauncherUpdater updater = myInstance.getHlaLauncherUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>PhysicalInterface Class</h3>


<h4>Working with PhysicalInterface Instances</h4>

To work with PhysicalInterface you first need to get the <code>HlaPhysicalInterfaceManager</code> instance which is
available through the <code>HlaWorld.getHlaPhysicalInterfaceManager</code> method.
<p>

To work with object instances you may use the <code>HlaPhysicalInterfaceManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaPhysicalInterfaceManager.getHlaPhysicalInterfaces()
HlaPhysicalInterfaceManager.getLocalHlaPhysicalInterfaces()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaPhysicalInterfaceManager.getPhysicalInterfaceByHlaInstanceName(String instanceName)
HlaPhysicalInterfaceManager.getPhysicalInterfaceByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each PhysicalInterface attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
boolean hasName();
String getName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getNameTimeStamped() throws HlaValueNotSetException;

boolean hasParentName();
String getParentName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getParentNameTimeStamped() throws HlaValueNotSetException;

boolean hasPosition();
double[/* 3 */] getPosition() throws HlaValueNotSetException;
HlaTimeStamped&lt;double[/* 3 */]> getPositionTimeStamped() throws HlaValueNotSetException;

boolean hasAttitude();
AttitudeQuaternion getAttitude() throws HlaValueNotSetException;
HlaTimeStamped&lt;AttitudeQuaternion> getAttitudeTimeStamped() throws HlaValueNotSetException;

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaPhysicalInterface.getHlaPhysicalInterfaceAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaPhysicalInterfaceValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaPhysicalInterfaceValueListener.nameUpdated(HlaPhysicalInterface physicalInterface, String name, boolean validOldName, String oldName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalInterfaceValueListener.parentNameUpdated(HlaPhysicalInterface physicalInterface, String parentName, boolean validOldParentName, String oldParentName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalInterfaceValueListener.positionUpdated(HlaPhysicalInterface physicalInterface, double[/* 3 */] position, boolean validOldPosition, double[/* 3 */] oldPosition, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaPhysicalInterfaceValueListener.attitudeUpdated(HlaPhysicalInterface physicalInterface, AttitudeQuaternion attitude, boolean validOldAttitude, AttitudeQuaternion oldAttitude, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

You may also implement the <code>HlaPhysicalInterfaceValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaPhysicalInterfaceListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaPhysicalInterfaceListener.attributesUpdated(HlaPhysicalInterface physicalInterface, Set&lt;HlaPhysicalInterfaceAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of PhysicalInterface:

<blockquote><pre>
HlaPhysicalInterfaceManager.createLocalHlaPhysicalInterface(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaPhysicalInterfaceManager.createLocalHlaPhysicalInterface(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaPhysicalInterfaceUpdater</code> as follows:

<blockquote><pre>
HlaPhysicalInterfaceUpdater updater = myInstance.getHlaPhysicalInterfaceUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>ReferenceFrame Class</h3>


<h4>Working with ReferenceFrame Instances</h4>

To work with ReferenceFrame you first need to get the <code>HlaReferenceFrameManager</code> instance which is
available through the <code>HlaWorld.getHlaReferenceFrameManager</code> method.
<p>

To work with object instances you may use the <code>HlaReferenceFrameManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaReferenceFrameManager.getHlaReferenceFrames()
HlaReferenceFrameManager.getLocalHlaReferenceFrames()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaReferenceFrameManager.getReferenceFrameByHlaInstanceName(String instanceName)
HlaReferenceFrameManager.getReferenceFrameByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each ReferenceFrame attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
boolean hasName();
String getName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getNameTimeStamped() throws HlaValueNotSetException;

boolean hasParentName();
String getParentName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getParentNameTimeStamped() throws HlaValueNotSetException;

boolean hasState();
SpaceTimeCoordinateState getState() throws HlaValueNotSetException;
HlaTimeStamped&lt;SpaceTimeCoordinateState> getStateTimeStamped() throws HlaValueNotSetException;

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaReferenceFrame.getHlaReferenceFrameAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaReferenceFrameValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaReferenceFrameValueListener.nameUpdated(HlaReferenceFrame referenceFrame, String name, boolean validOldName, String oldName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaReferenceFrameValueListener.parentNameUpdated(HlaReferenceFrame referenceFrame, String parentName, boolean validOldParentName, String oldParentName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaReferenceFrameValueListener.stateUpdated(HlaReferenceFrame referenceFrame, SpaceTimeCoordinateState state, boolean validOldState, SpaceTimeCoordinateState oldState, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

You may also implement the <code>HlaReferenceFrameValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaReferenceFrameListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaReferenceFrameListener.attributesUpdated(HlaReferenceFrame referenceFrame, Set&lt;HlaReferenceFrameAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of ReferenceFrame:

<blockquote><pre>
HlaReferenceFrameManager.createLocalHlaReferenceFrame(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaReferenceFrameManager.createLocalHlaReferenceFrame(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaReferenceFrameUpdater</code> as follows:

<blockquote><pre>
HlaReferenceFrameUpdater updater = myInstance.getHlaReferenceFrameUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>Moon Class</h3>


<h4>Working with Moon Instances</h4>

To work with Moon you first need to get the <code>HlaMoonManager</code> instance which is
available through the <code>HlaWorld.getHlaMoonManager</code> method.
<p>

To work with object instances you may use the <code>HlaMoonManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaMoonManager.getHlaMoons()
HlaMoonManager.getLocalHlaMoons()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaMoonManager.getMoonByHlaInstanceName(String instanceName)
HlaMoonManager.getMoonByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each Moon attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
boolean hasName();
String getName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getNameTimeStamped() throws HlaValueNotSetException;

boolean hasParentName();
String getParentName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getParentNameTimeStamped() throws HlaValueNotSetException;

boolean hasState();
SpaceTimeCoordinateState getState() throws HlaValueNotSetException;
HlaTimeStamped&lt;SpaceTimeCoordinateState> getStateTimeStamped() throws HlaValueNotSetException;

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaMoon.getHlaMoonAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaMoonValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaMoonValueListener.nameUpdated(HlaMoon moon, String name, boolean validOldName, String oldName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaMoonValueListener.parentNameUpdated(HlaMoon moon, String parentName, boolean validOldParentName, String oldParentName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaMoonValueListener.stateUpdated(HlaMoon moon, SpaceTimeCoordinateState state, boolean validOldState, SpaceTimeCoordinateState oldState, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

You may also implement the <code>HlaMoonValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaMoonListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaMoonListener.attributesUpdated(HlaMoon moon, Set&lt;HlaMoonAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of Moon:

<blockquote><pre>
HlaMoonManager.createLocalHlaMoon(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaMoonManager.createLocalHlaMoon(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaMoonUpdater</code> as follows:

<blockquote><pre>
HlaMoonUpdater updater = myInstance.getHlaMoonUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.




<h3>ExecutionConfiguration Class</h3>


<h4>Working with ExecutionConfiguration Instances</h4>

To work with ExecutionConfiguration you first need to get the <code>HlaExecutionConfigurationManager</code> instance which is
available through the <code>HlaWorld.getHlaExecutionConfigurationManager</code> method.
<p>

To work with object instances you may use the <code>HlaExecutionConfigurationManager</code> methods to get a
list of instances.

<blockquote><pre>
HlaExecutionConfigurationManager.getHlaExecutionConfigurations()
HlaExecutionConfigurationManager.getLocalHlaExecutionConfigurations()
</pre></blockquote>

You may also use the following methods to find a particular instance:

<blockquote><pre>
HlaExecutionConfigurationManager.getExecutionConfigurationByHlaInstanceName(String instanceName)
HlaExecutionConfigurationManager.getExecutionConfigurationByHlaInstanceHandle(byte[] encodedInstanceHandle)
</pre></blockquote>

The two last functions uses the <i>HLA instance name</i> and <i>HLA instance handle</i> from the HLA
federation.
<p>

For each ExecutionConfiguration attribute you may use the get function to retrieve the parameter values.
The following attributes are supported:

<blockquote><pre>
boolean hasRootFrameName();
String getRootFrameName() throws HlaValueNotSetException;
HlaTimeStamped&lt;String> getRootFrameNameTimeStamped() throws HlaValueNotSetException;

boolean hasScenarioTimeEpoch();
double getScenarioTimeEpoch() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getScenarioTimeEpochTimeStamped() throws HlaValueNotSetException;

boolean hasCurrentExecutionMode();
ExecutionMode getCurrentExecutionMode() throws HlaValueNotSetException;
HlaTimeStamped&lt;ExecutionMode> getCurrentExecutionModeTimeStamped() throws HlaValueNotSetException;

boolean hasNextExecutionMode();
ExecutionMode getNextExecutionMode() throws HlaValueNotSetException;
HlaTimeStamped&lt;ExecutionMode> getNextExecutionModeTimeStamped() throws HlaValueNotSetException;

boolean hasNextModeScenarioTime();
double getNextModeScenarioTime() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getNextModeScenarioTimeTimeStamped() throws HlaValueNotSetException;

boolean hasNextModeCteTime();
double getNextModeCteTime() throws HlaValueNotSetException;
HlaTimeStamped&lt;Double> getNextModeCteTimeTimeStamped() throws HlaValueNotSetException;

boolean hasLeastCommonTimeStep();
long getLeastCommonTimeStep() throws HlaValueNotSetException;
HlaTimeStamped&lt;Long> getLeastCommonTimeStepTimeStamped() throws HlaValueNotSetException;

</pre></blockquote>

To make sure that you get a consistent view of the attributes of an object you may also get a
snapshot of an instance using the call <code>HlaExecutionConfiguration.getHlaExecutionConfigurationAttributes</code> which supports the
same set of <code>has</code> and <code>get</code> methods as above.


<h4>Getting Update Notifications</h4>

If you want to get notifications when an instance is updated you simply create a subclass of the observer
<code>HlaExecutionConfigurationValueListener.Adapter</code> and register it as a listener for that instance. You may then
choose to implement some of the following methods:

<blockquote><pre>
HlaExecutionConfigurationValueListener.rootFrameNameUpdated(HlaExecutionConfiguration executionConfiguration, String rootFrameName, boolean validOldRootFrameName, String oldRootFrameName, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaExecutionConfigurationValueListener.scenarioTimeEpochUpdated(HlaExecutionConfiguration executionConfiguration, double scenarioTimeEpoch, boolean validOldScenarioTimeEpoch, double oldScenarioTimeEpoch, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaExecutionConfigurationValueListener.currentExecutionModeUpdated(HlaExecutionConfiguration executionConfiguration, ExecutionMode currentExecutionMode, boolean validOldCurrentExecutionMode, ExecutionMode oldCurrentExecutionMode, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaExecutionConfigurationValueListener.nextExecutionModeUpdated(HlaExecutionConfiguration executionConfiguration, ExecutionMode nextExecutionMode, boolean validOldNextExecutionMode, ExecutionMode oldNextExecutionMode, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaExecutionConfigurationValueListener.nextModeScenarioTimeUpdated(HlaExecutionConfiguration executionConfiguration, double nextModeScenarioTime, boolean validOldNextModeScenarioTime, double oldNextModeScenarioTime, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaExecutionConfigurationValueListener.nextModeCteTimeUpdated(HlaExecutionConfiguration executionConfiguration, double nextModeCteTime, boolean validOldNextModeCteTime, double oldNextModeCteTime, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
HlaExecutionConfigurationValueListener.leastCommonTimeStepUpdated(HlaExecutionConfiguration executionConfiguration, long leastCommonTimeStep, boolean validOldLeastCommonTimeStep, long oldLeastCommonTimeStep, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>

You may also implement the <code>HlaExecutionConfigurationValueListener</code> interface directly.
<p>

As an alternative you may use the <code>HlaExecutionConfigurationListener</code> that is called each time a group of
attributes are updated, instead of once for each attribute.

<blockquote><pre>
HlaExecutionConfigurationListener.attributesUpdated(HlaExecutionConfiguration executionConfiguration, Set&lt;HlaExecutionConfigurationAttributes.Attribute&gt; attributes, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime)
</pre></blockquote>





<h4>Working with Local Instances</h4>

To create a local instance of ExecutionConfiguration:

<blockquote><pre>
HlaExecutionConfigurationManager.createLocalHlaExecutionConfiguration(
)
</pre></blockquote>

If you want to define the <i>HLA instance name</i> in the federation you can use

<blockquote><pre>
HlaExecutionConfigurationManager.createLocalHlaExecutionConfiguration(
    String hlaInstanceName
)
</pre></blockquote>

This will fail (throw an exception) if the name is invalid or already in use. Instance names starting with HLA are invalid.
<p>

To update the attribute values of a local instance you can use the <code>HlaExecutionConfigurationUpdater</code> as follows:

<blockquote><pre>
HlaExecutionConfigurationUpdater updater = myInstance.getHlaExecutionConfigurationUpdater();

updater.set<i>AttributeName</i>(<i>new attribute value</i>);
updater.set<i>AttributeName</i>(<i>new attribute value</i>);

updater.sendUpdate();
</pre></blockquote>

Note that the update is not sent until the <code>sendUpdate</code> method is called. You have to create a new updater before each
update since an updater can not be reused.





<h2>Using Time Management</h2>

When calling <code>hlaWorld.connect()</code> time management will be enabled according to the settings in the <code>HlaSettings</code> that
was supplied when creating the <code>HlaWorld</code> object, or the default values if no <code>HlaSettings</code> was supplied.
<p>
   There are three different methods available to advance the logical time of your federate. They are available in the
   <code>HlaWorld</code> interface and each method has a slightly different use case as described below. All three functions
   will not return until the RTI has granted the federate a new logical time. This means that depending on how other federates
   uses time management, your federate might have to wait until other federates have advanced their logical time.

<h3>Advance to Next Frame</h3>

<blockquote><pre>
hlaWorld.advanceToNextFrame();
</pre></blockquote>

This method should be used when your federate is frame based. It will use the value you selected for step size and try to advance the logical time
of the federate to the federates current logical time + step size.
<p>
   <i>Example</i>: A federate with a step size of <code>5</code> would move its logical time as follows: <code>0, 5, 10, 15, ...</code>
<p>
   If the federate is frame based with an update rate of 10Hz, <code>advanceToNextFrame()</code> should be called 10 times each second.

<h3>Advance to Next Event</h3>

<blockquote><pre>
hlaWorld.advanceToNextEvent();
</pre></blockquote>

This method should be used when your federate is event based. It will try to advance the logical time of the federate to the logical time of the next
event it is going to receive, or if there is no event available, to the federates current logical time + step size. The <code>advanceToNextEvent()</code>
function supports a zero lookahead.
<p>
   <i>Example</i>: A federate with a step size of <code>5</code> that receives events at time <code>7</code> and <code>16</code> would move
   its logical time as follows: <code>0, 5, 7, 12, 16, 21, ...</code>
<p>
   Set your step size to a very large value to only be granted to a logical time if there is an event available.

<h3>Advance to Logical Time</h3>
<blockquote><pre>
HlaLogicalTime logicalTime = hlaWorld.createLogicalTime(100);
hlaWorld.advanceToLogicalTime(newLogicalTime);
</pre></blockquote>
This method should be used if you want to move the federates logical time to a specific logical time.
<p>
   <i>Example</i>: A frame based federate with step size of <code>2</code> which makes a <code>advanceToNextLogicalTime(100)</code> at logical time
   <code>10</code> would move its logical time as follows: <code>0, 2, 4, 6, 8, 10, 100, 102, 104, ...</code>

<h3>Default Send Time</h3>

If an update is sent without a specified logical time the default send time will be used.

<blockquote><pre>
updater.sendUpdate() // default send time will be used

HlaLogicalTime logicalTime = hlaWorld.createLogicalTime(100);
updater.sendUpdate(logicalTime) // specified logical time will be used
</pre></blockquote>

The default send time of the federate is the federates current logical time plus the lookahead. It is impossible to send an update with a specified
logical time that is lower than the default send time.

A default send time will be used when:
<ul>
   <li>Sending an update</li>
   <li>Sending an interaction</li>
   <li>Deleting an object</li>
</ul>

When creating a frame based federate lookahead will normally be the same as the step size, that way the default send time will be the logical time of the next frame.

<h3>Changing Step Size and Lookahead</h3>

Step size and lookahead can be changed at runtime using <code>HlaSettings</code>. After advancing the time, using any of the methods above,
<code>getStepSize</code> and <code>getLookahead</code> will be called and step size and lookahead will be updated accordingly.

<blockquote><pre>
// federate moves its logical time: 0, 1, 2, 3, 4,
hlaWorld.getSettings().setStepSize(2);
hlaWorld.getSettings().setLookahead(2);
// 5, 7, 9, ...
</pre></blockquote>

<h3>Invoke When Granted</h3>

When calling any of the three methods above to advance the time the federate will move into what is call the <i>advancing state</i>. After returning
the federate is in the <i>granted state</i>. It is during the <i>advancing state</i> the federate will receive time stamped messages from other federates.
<code>invokeWhenGranted</code> can be used to call a method when the federate has moved to the <i>granted state</i> with the additional guarantee that all listeners has been
called before executing the method.

<blockquote><pre>
void calculateNextState();

// inside a listener calculateNextState is posted to invokeWhenGranted
public void positionUpdated(HlaAircraft aircraft, PositionRec position, ...) {
   _myAircraft.setPosition(position);
   hlaWorld.invokeWhenGranted(new Runnable() {
      public void run() {
         calculateNextState();
      }
   });
}
// more listeners for speed, altitude and so on...

/*
 * calculateNextState will not be called until all listeners has been called,
 * guaranteeing that myAircraft has been completely updated.
 */
</pre></blockquote>

<h3>Save and Restore</h3>

Support for HLA Save and Restore are available in the <code>HlaSaveRestoreManager</code>.
Limitations in the current implementation:
<ul>
    <li>Instances can not be saved. If the <code>HlaWorld</code> has any
        local or remote instances the save will fail.</li>
    <li>Save and restore can only be performed within the same federation,
         it is not possible to save, resign, join a new federation and then restore.</li>
</ul>

It is expected that users of HLA Time Management might want to use this save and restore functionality
to restore the logical time, for example when doing Monte Carlo style simulations.
<p>
Read more in the <code>HlaSaveRestoreManager</code> Javadoc
(<a href="javadoc/core/HlaSaveRestoreManager.html">link</a>).


<h2>Working with Complex FOM Data types</h2>

FOM data types are converted to native Java types if it is possible. For example is the FOM
data type <code>HLAunicodeString</code> handled as a native Java <code>String</code>.
The table below lists FOM data types.
<br>
<table>
    <thead>
        <tr>
            <th>FOM Data type</th>
            <th>Example</th>
            <th>Java type</th>
            <th>Example</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td>Array</td>
            <td><code>HLAopaqueData</code></td>
            <td>Native Java array of the element type</td>
            <td><code>byte[]</code></td>
        </tr>

        <tr>
            <td>Basic</td>
            <td><code>HLAfloat64BE</code></td>
            <td>Native Java type</td>
            <td><code>double</code></td>
        </tr>

        <tr>
            <td>Enumerated</td>
            <td><code>HLAswitch</code></td>
            <td>Java enum</td>
            <td><code>HLAswitch</code></td>
        </tr>

        <tr>
            <td>Fixed Record</td>
            <td><code>VelocityVector</code></td>
            <td>Java class</td>
            <td><code>VelocityVector</code></td>
        </tr>

        <tr>
            <td>Simple</td>
            <td><code>HLAbyte</code></td>
            <td>Same as Basic type</td>
            <td><code>byte</code></td>
        </tr>

        <tr>
            <td>Variant Record</td>
            <td><code>Spatial</code></td>
            <td>Java class</td>
            <td><code>Spatial</code></td>
        </tr>
    </tbody>
</table>


<h3>Arrays</h3>

The following encodings are supported:
<ul>
    <li><code>HLAlengthlessVarArray</code> and <code>RPRlengthlessArray</code></li>
    <li><code>HLAunpaddedLengthlessVarArray</code> and <code>RPRunpaddedLengthlessArray</code></li>
    <li><code>HLAvariableArray</code></li>
    <li><code>HLApaddingTo16Array</code> and <code>RPRpaddingTo16Array</code></li>
    <li><code>HLApaddingTo32Array</code> and <code>RPRpaddingTo32Array</code></li>
    <li><code>HLApaddingTo64Array</code> and <code>RPRpaddingTo64Array</code></li>
    <li><code>HLAnullTerminatedArray</code> and <code>RPRnullTerminatedArray</code>, with <code>HLAASCIIchar</code> elements</li>
    <li><code>HLAfixedArray</code>, with a fixed cardinality</li>
</ul>

All <code>HLAvariableArrays</code> with element type <code>HLAASCIIchar</code> or <code>HLAunicodeChar</code>
are converted to Java <code>String</code>s and element type <code>HLAbyte</code> is converted to
Java <code>byte[]</code>.
How different data types are converted is described in the table below.
<br>
<h3>Basic</h3>

<table>
<thead>
    <tr>
        <th>Basic FOM data type</th>
        <th>Java data type</th>
    </tr>
</thead>

<tbody>
    <tr>
        <td><code>HLAoctet</code></td>
        <td><code>byte</code></td>
    </tr>

    <tr>
        <td><code>HLAoctetPairBE</code></td>
        <td><code>short</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger16BE </code></td>
        <td><code>short</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger16LE</code></td>
        <td><code>short</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger32BE</code></td>
        <td><code>int</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger32LE</code></td>
        <td><code>int</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger64BE</code></td>
        <td><code>long</code></td>
    </tr>

    <tr>
        <td><code>HLAinteger64LE</code></td>
        <td><code>long</code></td>
    </tr>

    <tr>
        <td><code>HLAfloat32BE</code></td>
        <td><code>float</code></td>
    </tr>

    <tr>
        <td><code>HLAfloat32LE</code></td>
        <td><code>float</code></td>
    </tr>

    <tr>
        <td><code>HLAfloat64BE</code></td>
        <td><code>double</code></td>
    </tr>

    <tr>
        <td><code>HLAfloat64LE</code></td>
        <td><code>double</code></td>
    </tr>

    <tr>
        <td><code>UnsignedShort</code></td>
        <td><code>int</code></td>
    </tr>

    <tr>
        <td><code>UnsignedInteger16BE</code></td>
        <td><code>int</code></td>
    </tr>

    <tr>
        <td><code>UnsignedInteger32BE</code></td>
        <td><code>long</code></td>
    </tr>

    <tr>
        <td><code>UnsignedInteger64BE</code></td>
        <td><code>BigInteger</code></td>
    </tr>

    <tr>
        <td><code>RPRunsignedInteger8BE</code></td>
        <td><code>int</code></td>
    </tr>

    <tr>
        <td><code>RPRunsignedInteger16BE</code></td>
        <td><code>int</code></td>
    </tr>

    <tr>
        <td><code>RPRunsignedInteger32BE</code></td>
        <td><code>long</code></td>
    </tr>

    <tr>
        <td><code>RPRunsignedInteger64BE</code></td>
        <td><code>BigInteger</code></td>
    </tr>
</tbody>
</table>


<h3>Enumerated</h3>

<code>HLAboolean</code>, <code>OMT13boolean</code> and <code>RPRboolean</code> are converted to native Java boolean, other enumerated data
types are converted to Java <code>enum</code>s with a <code>String</code> <i>name</i> and a <code>int</code> <i>ordinal</i>:

<blockquote><pre>
AirLineEnum.SAS.getName()
AirLineEnum.SAS.getOrdinal()
</pre></blockquote>

It is also possible to find the enum instance matching a name or an ordinal:

<blockquote><pre>
AirLineEnum value = AirLineEnum.find(2)
AirLineEnum value = AirLineEnum.find("SAS")
</pre></blockquote>


<h3>Fixed Record</h3>

Fixed records are converted to immutable Java classes with getters for each field and a static
create method to create a new instance. Basic functions like <code>toString()</code>, <code>equals()</code>
and <code>hashCode()</code> are supported according to Java's <code>Object</code> contract.

<blockquote><pre>
long latitude = 1;
long longitude = 20;
long altitude = 300;
PositionRec position = PositionRec.create(latitude, longitude, altitude);
position.getLatitude();
position.getLongitude();
position.getAltitude();

PositionRec.create(1, 2, 3).equals(PositionRec.create(1, 2, 3));  // true
</pre></blockquote>


<h3>Simple</h3>

Simple types are the same as their basic type.


<h3>Variant Record</h3>

Variant record are handled in the same way as Fixed record but <code>getDiscriminant()</code> can be used
to get the alternative of the instance and there is a specific create method for each alternative.
Alternatives with ranges are not supported.


<h2>More about Process Models</h2>

<h3>Auto Evoke Mode</h3>
All notifications for this HlaWorld instance will be delivered in the same thread, a thread that is created
by HlaWorld. The notifications will be delivered automatically, as fast as possible. No need to call any
<code>evoke</code> methods.
<p>

It is possible to disable automatic invocations of notifications with the <code>disableNotifications</code>.
No <i>new</i> notifications will be invoked after <code>disableNotifications()</code> has <i>returned</i>.
<p>

Note that notifications has to be manually enabled once disabled. This can be done with the following code:

<blockquote><pre>
hlaWorld.disableNotifications();
try {
   //perform task that generates notifications that can not be handled until after this block
} finally {
  hlaWorld.enableNotifications();
}
</pre></blockquote>

If this HlaWorld is in manual evoke mode, these methods will be a no op.


<h3>Manual Evoke Mode</h3>
In this mode notifications will be delivered when one of the <code>evoke</code> methods are called. The notification is
delivered in the same thread that makes the call to the notification method.
Note that the HlaWorld will be updated asynchronously, without the need for any <code>evoke</code> calls.
<p>

To process the notification one of the three <code>evoke</code> methods should be used:

<blockquote><pre>
hlaWorld.evoke();           // evoke one notification
hlaWorld.evokeAll();        // evoke all notifications
hlaWorld.evokeAll(1000);    // evoke notifications during 1000 ms
</pre></blockquote>

<dl>
    <dt>
        <code>void evoke()</code>
    </dt>
    <dd>
        Evokes a single notification from the notification queue. The notification will be called from this thread.
        This method will return after the notification has returned. If there are no pending notifications,
        this method will return immediately.
        <p>

        If this HlaWorld is in auto evoke mode, this method will be a no op.
        <p>

        Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    </dd>

    <dt>
        <code>void evokeAll()</code>
    </dt>
    <dd>
        Evokes all pending notifications from the notification queue. The notifications will be called from this
        thread, one at a time. This method returns when the notification queue is empty.
        <p>

        If this HlaWorld is in auto evoke mode, this method will be a no op.
        <p>

        Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    </dd>

    <dt>
        <code>void evokeAll(long millis)</code>
    </dt>
    <dd>
        Evokes notifications for at least <code>millis</code> milliseconds with this thread.
        If all pending notifications are processed before <code>millis</code> milliseconds have elapsed,
        the current thread is suspended until either some more notifications arrive, or the time has elapsed.
        <p>

        Note that this method could return even when there are pending notifications left.
        <p>

        If this HlaWorld is in auto evoke mode, this will suspend the current thread until the time has elapsed.

        Exceptions thrown in the user notification code will be posted to the <code>ExceptionListener</code>.
    </dd>
</dl>

It is possible to check the number of pending notifications with the <code>peek</code> method

<blockquote><pre>
int pending = hlaWorld.peek();
</pre></blockquote>


<h2>Handling Exceptions</h2>

All exceptions are subclasses of <code>HlaBaseException</code> for normal exceptions that has to be handled
and <code>HlaBaseRuntimeException</code> for all runtime exceptions that does not need to be handled.

<h3>HlaBaseException</h3>

<table>
<thead>
    <tr>
        <th>Exception</th>
        <th>Description</th>
    </tr>
</thead>

<tbody>
    <tr>
        <td><code>HlaAttributeAlreadyOwnedException</code></td>
        <td>The federate tried to cancel acquire ownership of an attribute is has already received ownership of</td>
    </tr>

    <tr>
        <td><code>HlaAttributeNotOwnedException</code></td>
        <td>The attribute failed to be updated due to lacking ownership</td>
    </tr>

    <tr>
        <td><code>HlaConnectException</code></td>
        <td>The connection to the RTI failed</td>
    </tr>

    <tr>
        <td><code>HlaFederateNotAcquiringAttributeException</code></td>
        <td>The federate tried to cancel acquire ownership of an attribute it is not currently trying to acquire ownership of</td>
    </tr>

    <tr>
        <td><code>HlaFomException</code></td>
        <td>The FOM does not match the FOM used to for code generation</td>
    </tr>

    <tr>
        <td><code>HlaIllegalInstanceNameException</code></td>
        <td>The requested <i>HLA instance name</i> is illegal</td>
    </tr>

    <tr>
        <td><code>HlaInTimeAdvancingStateException</code></td>
        <td>The operation cannot be performed in the time advancing state</td>
    </tr>

    <tr>
        <td><code>HlaInstanceNameInUseException</code></td>
        <td>The requested <i>HLA instance name</i> is already in use</td>
    </tr>

    <tr>
        <td><code>HlaInternalException</code></td>
        <td>An internal error occurred</td>
    </tr>

    <tr>
        <td><code>HlaInvalidLogicalTimeException</code></td>
        <td>The logical time is invalid or cannot be used</td>
    </tr>

    <tr>
        <td><code>HlaNotConnectedException</code></td>
        <td>Not connected to the RTI and joined to the federation</td>
    </tr>

    <tr>
        <td><code>HlaRestoreFederateException </code></td>
        <td>The restore operation failed</td>
    </tr>

    <tr>
        <td><code>HlaRtiException</code></td>
        <td>The RTI operation failed, for example <i>RTI internal error</i></td>
    </tr>

    <tr>
        <td><code>HlaSaveFederateException </code></td>
        <td>The save operation failed</td>
    </tr>
</tbody>
</table>


<h3>HlaBaseRuntimeException</h3>

<table>
<thead>
    <tr>
        <th>Exception</th>
        <th>Description</th>
    </tr>
</thead>

<tbody>
    <tr>
        <td><code>HlaDecodeException</code></td>
        <td>The attribute or parameter could not be encoded or decoded</td>
    </tr>

    <tr>
        <td><code>HlaUpdaterReusedException</code></td>
        <td>An updater was reused</td>
    </tr>

    <tr>
        <td><code>HlaValueNotSetException</code></td>
        <td>The attribute has no value</td>
    </tr>
    <tr>
        <td><code>HlaObjectInstanceIsRemovedException</code></td>
        <td>The object has been removed</td>
    </tr>
    <tr>
        <td><code>HlaFederateOwnsAttributeException</code></td>
        <td>Unable to acquire an attribute, the attribute is already owned.
            Ownership acquisitions are pending or attributes are owned
            and this not handled by the resign action when disconnecting.</td>
    </tr>
    <tr>
        <td><code>HlaIncompatibleHlaVersionException</code></td>
        <td>The currently used HLA version can't support the called method</td>
    </tr>
    <tr>
        <td><code>HlaInvalidLicenseException</code></td>
        <td>The license is not valid</td>
    </tr>
    <tr>
        <td><code>HlaSaveInProgressException</code></td>
        <td>The save operation is in progress</td>
    </tr>
    <tr>
        <td><code>HlaRestoreInProgressException</code></td>
        <td>The restore operation is in progress</td>
    </tr>
    <tr>
        <td><code>HlaInvalidInterestException</code></td>
        <td>The interest is not valid</td>
    </tr>
    <tr>
        <td><code>HlaNormalizerException</code></td>
        <td>The normalizer is not set, or could not be set correctly</td>
    </tr>
</tbody>
</table>

<h3>Asynchronous Exceptions</h3>

Asynchronous exceptions are handled with exceptions listeners on the HlaWorld instance for each federate.
Examples of asynchronous exceptions:
<ul>
    <li>Failure to decode received data</li>
    <li>Failure to encode data to send</li>
    <li>Exceptions thrown in the user notification code</li>
    <li>Disconnected from federation</li>
    <li>Failure to perform save/restore and achieve synchronization point</li>
</ul>

The exception listener can be set with the following code:
<blockquote><pre>
hlaWorld.setExceptionListener(new HlaWorld.ExceptionListener() {
   public void exceptionThrown(Throwable e, HlaTimeStamp timeStamp, HlaLogicalTime logicalTime) {
      // Handle exception...
   }
});
</pre></blockquote>

The default exception listener will just print out the exception on the console.


<h2>Integrating the Code into your Development Environment</h2>

An Ant script, named <code>build-generated.xml</code>, to build the HLA module has been generated. It is
suggested that you integrate this into your project as a sub-project or library. Note that you also
need to include the <code>rti_driver.jar</code> jar-file from the library subdir.

<p>
<i>
Generated by Pitch Developer Studio version 6.2.0
<br>
Licensed to Guidarly Joseph, SEE, Project Edition
<br>
Generated 2024-01-16 12:22:25 (-0500) by guida
<br>
Copyright (C) 2006-2023 Pitch Technologies AB. All rights reserved.
Use is subject to license terms.
</i>
</body>
</html>
